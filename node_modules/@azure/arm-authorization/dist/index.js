'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var tslib = require('tslib');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link PrincipalType} that the service accepts. */
exports.KnownPrincipalType = void 0;
(function (KnownPrincipalType) {
    /** User */
    KnownPrincipalType["User"] = "User";
    /** Group */
    KnownPrincipalType["Group"] = "Group";
    /** ServicePrincipal */
    KnownPrincipalType["ServicePrincipal"] = "ServicePrincipal";
    /** ForeignGroup */
    KnownPrincipalType["ForeignGroup"] = "ForeignGroup";
    /** Device */
    KnownPrincipalType["Device"] = "Device";
})(exports.KnownPrincipalType || (exports.KnownPrincipalType = {}));
/** Known values of {@link AssignmentType} that the service accepts. */
exports.KnownAssignmentType = void 0;
(function (KnownAssignmentType) {
    /** Activated */
    KnownAssignmentType["Activated"] = "Activated";
    /** Assigned */
    KnownAssignmentType["Assigned"] = "Assigned";
})(exports.KnownAssignmentType || (exports.KnownAssignmentType = {}));
/** Known values of {@link MemberType} that the service accepts. */
exports.KnownMemberType = void 0;
(function (KnownMemberType) {
    /** Inherited */
    KnownMemberType["Inherited"] = "Inherited";
    /** Direct */
    KnownMemberType["Direct"] = "Direct";
    /** Group */
    KnownMemberType["Group"] = "Group";
})(exports.KnownMemberType || (exports.KnownMemberType = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    /** Accepted */
    KnownStatus["Accepted"] = "Accepted";
    /** PendingEvaluation */
    KnownStatus["PendingEvaluation"] = "PendingEvaluation";
    /** Granted */
    KnownStatus["Granted"] = "Granted";
    /** Denied */
    KnownStatus["Denied"] = "Denied";
    /** PendingProvisioning */
    KnownStatus["PendingProvisioning"] = "PendingProvisioning";
    /** Provisioned */
    KnownStatus["Provisioned"] = "Provisioned";
    /** PendingRevocation */
    KnownStatus["PendingRevocation"] = "PendingRevocation";
    /** Revoked */
    KnownStatus["Revoked"] = "Revoked";
    /** Canceled */
    KnownStatus["Canceled"] = "Canceled";
    /** Failed */
    KnownStatus["Failed"] = "Failed";
    /** PendingApprovalProvisioning */
    KnownStatus["PendingApprovalProvisioning"] = "PendingApprovalProvisioning";
    /** PendingApproval */
    KnownStatus["PendingApproval"] = "PendingApproval";
    /** FailedAsResourceIsLocked */
    KnownStatus["FailedAsResourceIsLocked"] = "FailedAsResourceIsLocked";
    /** PendingAdminDecision */
    KnownStatus["PendingAdminDecision"] = "PendingAdminDecision";
    /** AdminApproved */
    KnownStatus["AdminApproved"] = "AdminApproved";
    /** AdminDenied */
    KnownStatus["AdminDenied"] = "AdminDenied";
    /** TimedOut */
    KnownStatus["TimedOut"] = "TimedOut";
    /** ProvisioningStarted */
    KnownStatus["ProvisioningStarted"] = "ProvisioningStarted";
    /** Invalid */
    KnownStatus["Invalid"] = "Invalid";
    /** PendingScheduleCreation */
    KnownStatus["PendingScheduleCreation"] = "PendingScheduleCreation";
    /** ScheduleCreated */
    KnownStatus["ScheduleCreated"] = "ScheduleCreated";
    /** PendingExternalProvisioning */
    KnownStatus["PendingExternalProvisioning"] = "PendingExternalProvisioning";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link RequestType} that the service accepts. */
exports.KnownRequestType = void 0;
(function (KnownRequestType) {
    /** AdminAssign */
    KnownRequestType["AdminAssign"] = "AdminAssign";
    /** AdminRemove */
    KnownRequestType["AdminRemove"] = "AdminRemove";
    /** AdminUpdate */
    KnownRequestType["AdminUpdate"] = "AdminUpdate";
    /** AdminExtend */
    KnownRequestType["AdminExtend"] = "AdminExtend";
    /** AdminRenew */
    KnownRequestType["AdminRenew"] = "AdminRenew";
    /** SelfActivate */
    KnownRequestType["SelfActivate"] = "SelfActivate";
    /** SelfDeactivate */
    KnownRequestType["SelfDeactivate"] = "SelfDeactivate";
    /** SelfExtend */
    KnownRequestType["SelfExtend"] = "SelfExtend";
    /** SelfRenew */
    KnownRequestType["SelfRenew"] = "SelfRenew";
})(exports.KnownRequestType || (exports.KnownRequestType = {}));
/** Known values of {@link Type} that the service accepts. */
exports.KnownType = void 0;
(function (KnownType) {
    /** AfterDuration */
    KnownType["AfterDuration"] = "AfterDuration";
    /** AfterDateTime */
    KnownType["AfterDateTime"] = "AfterDateTime";
    /** NoExpiration */
    KnownType["NoExpiration"] = "NoExpiration";
})(exports.KnownType || (exports.KnownType = {}));
/** Known values of {@link RoleManagementPolicyRuleType} that the service accepts. */
exports.KnownRoleManagementPolicyRuleType = void 0;
(function (KnownRoleManagementPolicyRuleType) {
    /** RoleManagementPolicyApprovalRule */
    KnownRoleManagementPolicyRuleType["RoleManagementPolicyApprovalRule"] = "RoleManagementPolicyApprovalRule";
    /** RoleManagementPolicyAuthenticationContextRule */
    KnownRoleManagementPolicyRuleType["RoleManagementPolicyAuthenticationContextRule"] = "RoleManagementPolicyAuthenticationContextRule";
    /** RoleManagementPolicyEnablementRule */
    KnownRoleManagementPolicyRuleType["RoleManagementPolicyEnablementRule"] = "RoleManagementPolicyEnablementRule";
    /** RoleManagementPolicyExpirationRule */
    KnownRoleManagementPolicyRuleType["RoleManagementPolicyExpirationRule"] = "RoleManagementPolicyExpirationRule";
    /** RoleManagementPolicyNotificationRule */
    KnownRoleManagementPolicyRuleType["RoleManagementPolicyNotificationRule"] = "RoleManagementPolicyNotificationRule";
})(exports.KnownRoleManagementPolicyRuleType || (exports.KnownRoleManagementPolicyRuleType = {}));
/** Known values of {@link ApprovalMode} that the service accepts. */
exports.KnownApprovalMode = void 0;
(function (KnownApprovalMode) {
    /** SingleStage */
    KnownApprovalMode["SingleStage"] = "SingleStage";
    /** Serial */
    KnownApprovalMode["Serial"] = "Serial";
    /** Parallel */
    KnownApprovalMode["Parallel"] = "Parallel";
    /** NoApproval */
    KnownApprovalMode["NoApproval"] = "NoApproval";
})(exports.KnownApprovalMode || (exports.KnownApprovalMode = {}));
/** Known values of {@link UserType} that the service accepts. */
exports.KnownUserType = void 0;
(function (KnownUserType) {
    /** User */
    KnownUserType["User"] = "User";
    /** Group */
    KnownUserType["Group"] = "Group";
})(exports.KnownUserType || (exports.KnownUserType = {}));
/** Known values of {@link EnablementRules} that the service accepts. */
exports.KnownEnablementRules = void 0;
(function (KnownEnablementRules) {
    /** MultiFactorAuthentication */
    KnownEnablementRules["MultiFactorAuthentication"] = "MultiFactorAuthentication";
    /** Justification */
    KnownEnablementRules["Justification"] = "Justification";
    /** Ticketing */
    KnownEnablementRules["Ticketing"] = "Ticketing";
})(exports.KnownEnablementRules || (exports.KnownEnablementRules = {}));
/** Known values of {@link NotificationDeliveryMechanism} that the service accepts. */
exports.KnownNotificationDeliveryMechanism = void 0;
(function (KnownNotificationDeliveryMechanism) {
    /** Email */
    KnownNotificationDeliveryMechanism["Email"] = "Email";
})(exports.KnownNotificationDeliveryMechanism || (exports.KnownNotificationDeliveryMechanism = {}));
/** Known values of {@link NotificationLevel} that the service accepts. */
exports.KnownNotificationLevel = void 0;
(function (KnownNotificationLevel) {
    /** None */
    KnownNotificationLevel["None"] = "None";
    /** Critical */
    KnownNotificationLevel["Critical"] = "Critical";
    /** All */
    KnownNotificationLevel["All"] = "All";
})(exports.KnownNotificationLevel || (exports.KnownNotificationLevel = {}));
/** Known values of {@link RecipientType} that the service accepts. */
exports.KnownRecipientType = void 0;
(function (KnownRecipientType) {
    /** Requestor */
    KnownRecipientType["Requestor"] = "Requestor";
    /** Approver */
    KnownRecipientType["Approver"] = "Approver";
    /** Admin */
    KnownRecipientType["Admin"] = "Admin";
})(exports.KnownRecipientType || (exports.KnownRecipientType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ClassicAdministratorListResult = {
    type: {
        name: "Composite",
        className: "ClassicAdministratorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClassicAdministrator"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClassicAdministrator = {
    type: {
        name: "Composite",
        className: "ClassicAdministrator",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            emailAddress: {
                serializedName: "properties.emailAddress",
                type: {
                    name: "String"
                }
            },
            role: {
                serializedName: "properties.role",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const DenyAssignmentListResult = {
    type: {
        name: "Composite",
        className: "DenyAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DenyAssignment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DenyAssignment = {
    type: {
        name: "Composite",
        className: "DenyAssignment",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            denyAssignmentName: {
                serializedName: "properties.denyAssignmentName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "properties.permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DenyAssignmentPermission"
                        }
                    }
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            doNotApplyToChildScopes: {
                serializedName: "properties.doNotApplyToChildScopes",
                type: {
                    name: "Boolean"
                }
            },
            principals: {
                serializedName: "properties.principals",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Principal"
                        }
                    }
                }
            },
            excludePrincipals: {
                serializedName: "properties.excludePrincipals",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Principal"
                        }
                    }
                }
            },
            isSystemProtected: {
                serializedName: "properties.isSystemProtected",
                type: {
                    name: "Boolean"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            updatedOn: {
                serializedName: "properties.updatedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            createdBy: {
                serializedName: "properties.createdBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            updatedBy: {
                serializedName: "properties.updatedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DenyAssignmentPermission = {
    type: {
        name: "Composite",
        className: "DenyAssignmentPermission",
        modelProperties: {
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notActions: {
                serializedName: "notActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dataActions: {
                serializedName: "dataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notDataActions: {
                serializedName: "notDataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            condition: {
                serializedName: "condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "conditionVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Principal = {
    type: {
        name: "Composite",
        className: "Principal",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            email: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProviderOperationsMetadata = {
    type: {
        name: "Composite",
        className: "ProviderOperationsMetadata",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceType"
                        }
                    }
                }
            },
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderOperation"
                        }
                    }
                }
            }
        }
    }
};
const ResourceType = {
    type: {
        name: "Composite",
        className: "ResourceType",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderOperation"
                        }
                    }
                }
            }
        }
    }
};
const ProviderOperation = {
    type: {
        name: "Composite",
        className: "ProviderOperation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ProviderOperationsMetadataListResult = {
    type: {
        name: "Composite",
        className: "ProviderOperationsMetadataListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderOperationsMetadata"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentListResult = {
    type: {
        name: "Composite",
        className: "RoleAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleAssignment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignment = {
    type: {
        name: "Composite",
        className: "RoleAssignment",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            updatedOn: {
                serializedName: "properties.updatedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            createdBy: {
                serializedName: "properties.createdBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            updatedBy: {
                serializedName: "properties.updatedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            delegatedManagedIdentityResourceId: {
                serializedName: "properties.delegatedManagedIdentityResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentCreateParameters = {
    type: {
        name: "Composite",
        className: "RoleAssignmentCreateParameters",
        modelProperties: {
            scope: {
                serializedName: "properties.scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                required: true,
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                required: true,
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            updatedOn: {
                serializedName: "properties.updatedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            createdBy: {
                serializedName: "properties.createdBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            updatedBy: {
                serializedName: "properties.updatedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            delegatedManagedIdentityResourceId: {
                serializedName: "properties.delegatedManagedIdentityResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PermissionGetResult = {
    type: {
        name: "Composite",
        className: "PermissionGetResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Permission"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Permission = {
    type: {
        name: "Composite",
        className: "Permission",
        modelProperties: {
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notActions: {
                serializedName: "notActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dataActions: {
                serializedName: "dataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notDataActions: {
                serializedName: "notDataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RoleDefinition = {
    type: {
        name: "Composite",
        className: "RoleDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roleName: {
                serializedName: "properties.roleName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            roleType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "properties.permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Permission"
                        }
                    }
                }
            },
            assignableScopes: {
                serializedName: "properties.assignableScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            updatedOn: {
                serializedName: "properties.updatedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            createdBy: {
                serializedName: "properties.createdBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            updatedBy: {
                serializedName: "properties.updatedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleDefinitionListResult = {
    type: {
        name: "Composite",
        className: "RoleDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EligibleChildResourcesListResult = {
    type: {
        name: "Composite",
        className: "EligibleChildResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EligibleChildResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EligibleChildResource = {
    type: {
        name: "Composite",
        className: "EligibleChildResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentSchedule = {
    type: {
        name: "Composite",
        className: "RoleAssignmentSchedule",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            },
            roleAssignmentScheduleRequestId: {
                serializedName: "properties.roleAssignmentScheduleRequestId",
                type: {
                    name: "String"
                }
            },
            linkedRoleEligibilityScheduleId: {
                serializedName: "properties.linkedRoleEligibilityScheduleId",
                type: {
                    name: "String"
                }
            },
            assignmentType: {
                serializedName: "properties.assignmentType",
                type: {
                    name: "String"
                }
            },
            memberType: {
                serializedName: "properties.memberType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            startDateTime: {
                serializedName: "properties.startDateTime",
                type: {
                    name: "DateTime"
                }
            },
            endDateTime: {
                serializedName: "properties.endDateTime",
                type: {
                    name: "DateTime"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            },
            updatedOn: {
                serializedName: "properties.updatedOn",
                type: {
                    name: "DateTime"
                }
            },
            expandedProperties: {
                serializedName: "properties.expandedProperties",
                type: {
                    name: "Composite",
                    className: "ExpandedProperties"
                }
            }
        }
    }
};
const ExpandedProperties = {
    type: {
        name: "Composite",
        className: "ExpandedProperties",
        modelProperties: {
            scope: {
                serializedName: "scope",
                type: {
                    name: "Composite",
                    className: "ExpandedPropertiesScope"
                }
            },
            roleDefinition: {
                serializedName: "roleDefinition",
                type: {
                    name: "Composite",
                    className: "ExpandedPropertiesRoleDefinition"
                }
            },
            principal: {
                serializedName: "principal",
                type: {
                    name: "Composite",
                    className: "ExpandedPropertiesPrincipal"
                }
            }
        }
    }
};
const ExpandedPropertiesScope = {
    type: {
        name: "Composite",
        className: "ExpandedPropertiesScope",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpandedPropertiesRoleDefinition = {
    type: {
        name: "Composite",
        className: "ExpandedPropertiesRoleDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpandedPropertiesPrincipal = {
    type: {
        name: "Composite",
        className: "ExpandedPropertiesPrincipal",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            email: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleListResult = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleAssignmentSchedule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleInstanceListResult = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleInstanceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleAssignmentScheduleInstance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleInstance = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleInstance",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            },
            roleAssignmentScheduleId: {
                serializedName: "properties.roleAssignmentScheduleId",
                type: {
                    name: "String"
                }
            },
            originRoleAssignmentId: {
                serializedName: "properties.originRoleAssignmentId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            startDateTime: {
                serializedName: "properties.startDateTime",
                type: {
                    name: "DateTime"
                }
            },
            endDateTime: {
                serializedName: "properties.endDateTime",
                type: {
                    name: "DateTime"
                }
            },
            linkedRoleEligibilityScheduleId: {
                serializedName: "properties.linkedRoleEligibilityScheduleId",
                type: {
                    name: "String"
                }
            },
            linkedRoleEligibilityScheduleInstanceId: {
                serializedName: "properties.linkedRoleEligibilityScheduleInstanceId",
                type: {
                    name: "String"
                }
            },
            assignmentType: {
                serializedName: "properties.assignmentType",
                type: {
                    name: "String"
                }
            },
            memberType: {
                serializedName: "properties.memberType",
                type: {
                    name: "String"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            },
            expandedProperties: {
                serializedName: "properties.expandedProperties",
                type: {
                    name: "Composite",
                    className: "ExpandedProperties"
                }
            }
        }
    }
};
const RoleAssignmentScheduleRequest = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleRequest",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requestType: {
                serializedName: "properties.requestType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            approvalId: {
                serializedName: "properties.approvalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetRoleAssignmentScheduleId: {
                serializedName: "properties.targetRoleAssignmentScheduleId",
                type: {
                    name: "String"
                }
            },
            targetRoleAssignmentScheduleInstanceId: {
                serializedName: "properties.targetRoleAssignmentScheduleInstanceId",
                type: {
                    name: "String"
                }
            },
            scheduleInfo: {
                serializedName: "properties.scheduleInfo",
                type: {
                    name: "Composite",
                    className: "RoleAssignmentScheduleRequestPropertiesScheduleInfo"
                }
            },
            linkedRoleEligibilityScheduleId: {
                serializedName: "properties.linkedRoleEligibilityScheduleId",
                type: {
                    name: "String"
                }
            },
            justification: {
                serializedName: "properties.justification",
                type: {
                    name: "String"
                }
            },
            ticketInfo: {
                serializedName: "properties.ticketInfo",
                type: {
                    name: "Composite",
                    className: "RoleAssignmentScheduleRequestPropertiesTicketInfo"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            requestorId: {
                serializedName: "properties.requestorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expandedProperties: {
                serializedName: "properties.expandedProperties",
                type: {
                    name: "Composite",
                    className: "ExpandedProperties"
                }
            }
        }
    }
};
const RoleAssignmentScheduleRequestPropertiesScheduleInfo = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleRequestPropertiesScheduleInfo",
        modelProperties: {
            startDateTime: {
                serializedName: "startDateTime",
                type: {
                    name: "DateTime"
                }
            },
            expiration: {
                serializedName: "expiration",
                type: {
                    name: "Composite",
                    className: "RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration"
                }
            }
        }
    }
};
const RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            endDateTime: {
                serializedName: "endDateTime",
                type: {
                    name: "DateTime"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleRequestPropertiesTicketInfo = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleRequestPropertiesTicketInfo",
        modelProperties: {
            ticketNumber: {
                serializedName: "ticketNumber",
                type: {
                    name: "String"
                }
            },
            ticketSystem: {
                serializedName: "ticketSystem",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleRequestListResult = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleRequestListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleAssignmentScheduleRequest"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilitySchedule = {
    type: {
        name: "Composite",
        className: "RoleEligibilitySchedule",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            },
            roleEligibilityScheduleRequestId: {
                serializedName: "properties.roleEligibilityScheduleRequestId",
                type: {
                    name: "String"
                }
            },
            memberType: {
                serializedName: "properties.memberType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            startDateTime: {
                serializedName: "properties.startDateTime",
                type: {
                    name: "DateTime"
                }
            },
            endDateTime: {
                serializedName: "properties.endDateTime",
                type: {
                    name: "DateTime"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            },
            updatedOn: {
                serializedName: "properties.updatedOn",
                type: {
                    name: "DateTime"
                }
            },
            expandedProperties: {
                serializedName: "properties.expandedProperties",
                type: {
                    name: "Composite",
                    className: "ExpandedProperties"
                }
            }
        }
    }
};
const RoleEligibilityScheduleListResult = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleEligibilitySchedule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleInstanceListResult = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleInstanceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleEligibilityScheduleInstance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleInstance = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleInstance",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            },
            roleEligibilityScheduleId: {
                serializedName: "properties.roleEligibilityScheduleId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            startDateTime: {
                serializedName: "properties.startDateTime",
                type: {
                    name: "DateTime"
                }
            },
            endDateTime: {
                serializedName: "properties.endDateTime",
                type: {
                    name: "DateTime"
                }
            },
            memberType: {
                serializedName: "properties.memberType",
                type: {
                    name: "String"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            },
            expandedProperties: {
                serializedName: "properties.expandedProperties",
                type: {
                    name: "Composite",
                    className: "ExpandedProperties"
                }
            }
        }
    }
};
const RoleEligibilityScheduleRequest = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleRequest",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "properties.principalType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requestType: {
                serializedName: "properties.requestType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            approvalId: {
                serializedName: "properties.approvalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scheduleInfo: {
                serializedName: "properties.scheduleInfo",
                type: {
                    name: "Composite",
                    className: "RoleEligibilityScheduleRequestPropertiesScheduleInfo"
                }
            },
            targetRoleEligibilityScheduleId: {
                serializedName: "properties.targetRoleEligibilityScheduleId",
                type: {
                    name: "String"
                }
            },
            targetRoleEligibilityScheduleInstanceId: {
                serializedName: "properties.targetRoleEligibilityScheduleInstanceId",
                type: {
                    name: "String"
                }
            },
            justification: {
                serializedName: "properties.justification",
                type: {
                    name: "String"
                }
            },
            ticketInfo: {
                serializedName: "properties.ticketInfo",
                type: {
                    name: "Composite",
                    className: "RoleEligibilityScheduleRequestPropertiesTicketInfo"
                }
            },
            condition: {
                serializedName: "properties.condition",
                type: {
                    name: "String"
                }
            },
            conditionVersion: {
                serializedName: "properties.conditionVersion",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            requestorId: {
                serializedName: "properties.requestorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expandedProperties: {
                serializedName: "properties.expandedProperties",
                type: {
                    name: "Composite",
                    className: "ExpandedProperties"
                }
            }
        }
    }
};
const RoleEligibilityScheduleRequestPropertiesScheduleInfo = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleRequestPropertiesScheduleInfo",
        modelProperties: {
            startDateTime: {
                serializedName: "startDateTime",
                type: {
                    name: "DateTime"
                }
            },
            expiration: {
                serializedName: "expiration",
                type: {
                    name: "Composite",
                    className: "RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration"
                }
            }
        }
    }
};
const RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            endDateTime: {
                serializedName: "endDateTime",
                type: {
                    name: "DateTime"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleRequestPropertiesTicketInfo = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleRequestPropertiesTicketInfo",
        modelProperties: {
            ticketNumber: {
                serializedName: "ticketNumber",
                type: {
                    name: "String"
                }
            },
            ticketSystem: {
                serializedName: "ticketSystem",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleRequestListResult = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleRequestListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleEligibilityScheduleRequest"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleManagementPolicy = {
    type: {
        name: "Composite",
        className: "RoleManagementPolicy",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            isOrganizationDefault: {
                serializedName: "properties.isOrganizationDefault",
                type: {
                    name: "Boolean"
                }
            },
            lastModifiedBy: {
                serializedName: "properties.lastModifiedBy",
                type: {
                    name: "Composite",
                    className: "Principal"
                }
            },
            lastModifiedDateTime: {
                serializedName: "properties.lastModifiedDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleManagementPolicyRule"
                        }
                    }
                }
            },
            effectiveRules: {
                serializedName: "properties.effectiveRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleManagementPolicyRule"
                        }
                    }
                }
            },
            policyProperties: {
                serializedName: "properties.policyProperties",
                type: {
                    name: "Composite",
                    className: "PolicyProperties"
                }
            }
        }
    }
};
const RoleManagementPolicyRule = {
    type: {
        name: "Composite",
        className: "RoleManagementPolicyRule",
        uberParent: "RoleManagementPolicyRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "Composite",
                    className: "RoleManagementPolicyRuleTarget"
                }
            }
        }
    }
};
const RoleManagementPolicyRuleTarget = {
    type: {
        name: "Composite",
        className: "RoleManagementPolicyRuleTarget",
        modelProperties: {
            caller: {
                serializedName: "caller",
                type: {
                    name: "String"
                }
            },
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            level: {
                serializedName: "level",
                type: {
                    name: "String"
                }
            },
            targetObjects: {
                serializedName: "targetObjects",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            inheritableSettings: {
                serializedName: "inheritableSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            enforcedSettings: {
                serializedName: "enforcedSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PolicyProperties = {
    type: {
        name: "Composite",
        className: "PolicyProperties",
        modelProperties: {
            scope: {
                serializedName: "scope",
                type: {
                    name: "Composite",
                    className: "PolicyPropertiesScope"
                }
            }
        }
    }
};
const PolicyPropertiesScope = {
    type: {
        name: "Composite",
        className: "PolicyPropertiesScope",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleManagementPolicyListResult = {
    type: {
        name: "Composite",
        className: "RoleManagementPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleManagementPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleManagementPolicyAssignment = {
    type: {
        name: "Composite",
        className: "RoleManagementPolicyAssignment",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            policyId: {
                serializedName: "properties.policyId",
                type: {
                    name: "String"
                }
            },
            effectiveRules: {
                serializedName: "properties.effectiveRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleManagementPolicyRule"
                        }
                    }
                }
            },
            policyAssignmentProperties: {
                serializedName: "properties.policyAssignmentProperties",
                type: {
                    name: "Composite",
                    className: "PolicyAssignmentProperties"
                }
            }
        }
    }
};
const PolicyAssignmentProperties = {
    type: {
        name: "Composite",
        className: "PolicyAssignmentProperties",
        modelProperties: {
            scope: {
                serializedName: "scope",
                type: {
                    name: "Composite",
                    className: "PolicyAssignmentPropertiesScope"
                }
            },
            roleDefinition: {
                serializedName: "roleDefinition",
                type: {
                    name: "Composite",
                    className: "PolicyAssignmentPropertiesRoleDefinition"
                }
            },
            policy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "PolicyAssignmentPropertiesPolicy"
                }
            }
        }
    }
};
const PolicyAssignmentPropertiesScope = {
    type: {
        name: "Composite",
        className: "PolicyAssignmentPropertiesScope",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyAssignmentPropertiesRoleDefinition = {
    type: {
        name: "Composite",
        className: "PolicyAssignmentPropertiesRoleDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyAssignmentPropertiesPolicy = {
    type: {
        name: "Composite",
        className: "PolicyAssignmentPropertiesPolicy",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "Composite",
                    className: "Principal"
                }
            },
            lastModifiedDateTime: {
                serializedName: "lastModifiedDateTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RoleManagementPolicyAssignmentListResult = {
    type: {
        name: "Composite",
        className: "RoleManagementPolicyAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleManagementPolicyAssignment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DenyAssignmentFilter = {
    type: {
        name: "Composite",
        className: "DenyAssignmentFilter",
        modelProperties: {
            denyAssignmentName: {
                serializedName: "denyAssignmentName",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            gdprExportPrincipalId: {
                serializedName: "gdprExportPrincipalId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidationResponseErrorInfo = {
    type: {
        name: "Composite",
        className: "ValidationResponseErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidationResponse = {
    type: {
        name: "Composite",
        className: "ValidationResponse",
        modelProperties: {
            isValid: {
                serializedName: "isValid",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            errorInfo: {
                serializedName: "errorInfo",
                type: {
                    name: "Composite",
                    className: "ValidationResponseErrorInfo"
                }
            }
        }
    }
};
const RoleAssignmentFilter = {
    type: {
        name: "Composite",
        className: "RoleAssignmentFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleDefinitionFilter = {
    type: {
        name: "Composite",
        className: "RoleDefinitionFilter",
        modelProperties: {
            roleName: {
                serializedName: "roleName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApprovalSettings = {
    type: {
        name: "Composite",
        className: "ApprovalSettings",
        modelProperties: {
            isApprovalRequired: {
                serializedName: "isApprovalRequired",
                type: {
                    name: "Boolean"
                }
            },
            isApprovalRequiredForExtension: {
                serializedName: "isApprovalRequiredForExtension",
                type: {
                    name: "Boolean"
                }
            },
            isRequestorJustificationRequired: {
                serializedName: "isRequestorJustificationRequired",
                type: {
                    name: "Boolean"
                }
            },
            approvalMode: {
                serializedName: "approvalMode",
                type: {
                    name: "String"
                }
            },
            approvalStages: {
                serializedName: "approvalStages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApprovalStage"
                        }
                    }
                }
            }
        }
    }
};
const ApprovalStage = {
    type: {
        name: "Composite",
        className: "ApprovalStage",
        modelProperties: {
            approvalStageTimeOutInDays: {
                serializedName: "approvalStageTimeOutInDays",
                type: {
                    name: "Number"
                }
            },
            isApproverJustificationRequired: {
                serializedName: "isApproverJustificationRequired",
                type: {
                    name: "Boolean"
                }
            },
            escalationTimeInMinutes: {
                serializedName: "escalationTimeInMinutes",
                type: {
                    name: "Number"
                }
            },
            primaryApprovers: {
                serializedName: "primaryApprovers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserSet"
                        }
                    }
                }
            },
            isEscalationEnabled: {
                serializedName: "isEscalationEnabled",
                type: {
                    name: "Boolean"
                }
            },
            escalationApprovers: {
                serializedName: "escalationApprovers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserSet"
                        }
                    }
                }
            }
        }
    }
};
const UserSet = {
    type: {
        name: "Composite",
        className: "UserSet",
        modelProperties: {
            userType: {
                serializedName: "userType",
                type: {
                    name: "String"
                }
            },
            isBackup: {
                serializedName: "isBackup",
                type: {
                    name: "Boolean"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleFilter = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleInstanceFilter = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleInstanceFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            roleAssignmentScheduleId: {
                serializedName: "roleAssignmentScheduleId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentScheduleRequestFilter = {
    type: {
        name: "Composite",
        className: "RoleAssignmentScheduleRequestFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            requestorId: {
                serializedName: "requestorId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleFilter = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleInstanceFilter = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleInstanceFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            roleEligibilityScheduleId: {
                serializedName: "roleEligibilityScheduleId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleEligibilityScheduleRequestFilter = {
    type: {
        name: "Composite",
        className: "RoleEligibilityScheduleRequestFilter",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            requestorId: {
                serializedName: "requestorId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleManagementPolicyApprovalRule = {
    serializedName: "RoleManagementPolicyApprovalRule",
    type: {
        name: "Composite",
        className: "RoleManagementPolicyApprovalRule",
        uberParent: "RoleManagementPolicyRule",
        polymorphicDiscriminator: RoleManagementPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RoleManagementPolicyRule.type.modelProperties), { setting: {
                serializedName: "setting",
                type: {
                    name: "Composite",
                    className: "ApprovalSettings"
                }
            } })
    }
};
const RoleManagementPolicyAuthenticationContextRule = {
    serializedName: "RoleManagementPolicyAuthenticationContextRule",
    type: {
        name: "Composite",
        className: "RoleManagementPolicyAuthenticationContextRule",
        uberParent: "RoleManagementPolicyRule",
        polymorphicDiscriminator: RoleManagementPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RoleManagementPolicyRule.type.modelProperties), { isEnabled: {
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            }, claimValue: {
                serializedName: "claimValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const RoleManagementPolicyEnablementRule = {
    serializedName: "RoleManagementPolicyEnablementRule",
    type: {
        name: "Composite",
        className: "RoleManagementPolicyEnablementRule",
        uberParent: "RoleManagementPolicyRule",
        polymorphicDiscriminator: RoleManagementPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RoleManagementPolicyRule.type.modelProperties), { enabledRules: {
                serializedName: "enabledRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const RoleManagementPolicyExpirationRule = {
    serializedName: "RoleManagementPolicyExpirationRule",
    type: {
        name: "Composite",
        className: "RoleManagementPolicyExpirationRule",
        uberParent: "RoleManagementPolicyRule",
        polymorphicDiscriminator: RoleManagementPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RoleManagementPolicyRule.type.modelProperties), { isExpirationRequired: {
                serializedName: "isExpirationRequired",
                type: {
                    name: "Boolean"
                }
            }, maximumDuration: {
                serializedName: "maximumDuration",
                type: {
                    name: "String"
                }
            } })
    }
};
const RoleManagementPolicyNotificationRule = {
    serializedName: "RoleManagementPolicyNotificationRule",
    type: {
        name: "Composite",
        className: "RoleManagementPolicyNotificationRule",
        uberParent: "RoleManagementPolicyRule",
        polymorphicDiscriminator: RoleManagementPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RoleManagementPolicyRule.type.modelProperties), { notificationType: {
                serializedName: "notificationType",
                type: {
                    name: "String"
                }
            }, notificationLevel: {
                serializedName: "notificationLevel",
                type: {
                    name: "String"
                }
            }, recipientType: {
                serializedName: "recipientType",
                type: {
                    name: "String"
                }
            }, notificationRecipients: {
                serializedName: "notificationRecipients",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isDefaultRecipientsEnabled: {
                serializedName: "isDefaultRecipientsEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
let discriminators = {
    RoleManagementPolicyRule: RoleManagementPolicyRule,
    "RoleManagementPolicyRule.RoleManagementPolicyApprovalRule": RoleManagementPolicyApprovalRule,
    "RoleManagementPolicyRule.RoleManagementPolicyAuthenticationContextRule": RoleManagementPolicyAuthenticationContextRule,
    "RoleManagementPolicyRule.RoleManagementPolicyEnablementRule": RoleManagementPolicyEnablementRule,
    "RoleManagementPolicyRule.RoleManagementPolicyExpirationRule": RoleManagementPolicyExpirationRule,
    "RoleManagementPolicyRule.RoleManagementPolicyNotificationRule": RoleManagementPolicyNotificationRule
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ClassicAdministratorListResult: ClassicAdministratorListResult,
    ClassicAdministrator: ClassicAdministrator,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    DenyAssignmentListResult: DenyAssignmentListResult,
    DenyAssignment: DenyAssignment,
    DenyAssignmentPermission: DenyAssignmentPermission,
    Principal: Principal,
    ProviderOperationsMetadata: ProviderOperationsMetadata,
    ResourceType: ResourceType,
    ProviderOperation: ProviderOperation,
    ProviderOperationsMetadataListResult: ProviderOperationsMetadataListResult,
    RoleAssignmentListResult: RoleAssignmentListResult,
    RoleAssignment: RoleAssignment,
    RoleAssignmentCreateParameters: RoleAssignmentCreateParameters,
    PermissionGetResult: PermissionGetResult,
    Permission: Permission,
    RoleDefinition: RoleDefinition,
    RoleDefinitionListResult: RoleDefinitionListResult,
    EligibleChildResourcesListResult: EligibleChildResourcesListResult,
    EligibleChildResource: EligibleChildResource,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    RoleAssignmentSchedule: RoleAssignmentSchedule,
    ExpandedProperties: ExpandedProperties,
    ExpandedPropertiesScope: ExpandedPropertiesScope,
    ExpandedPropertiesRoleDefinition: ExpandedPropertiesRoleDefinition,
    ExpandedPropertiesPrincipal: ExpandedPropertiesPrincipal,
    RoleAssignmentScheduleListResult: RoleAssignmentScheduleListResult,
    RoleAssignmentScheduleInstanceListResult: RoleAssignmentScheduleInstanceListResult,
    RoleAssignmentScheduleInstance: RoleAssignmentScheduleInstance,
    RoleAssignmentScheduleRequest: RoleAssignmentScheduleRequest,
    RoleAssignmentScheduleRequestPropertiesScheduleInfo: RoleAssignmentScheduleRequestPropertiesScheduleInfo,
    RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration: RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration,
    RoleAssignmentScheduleRequestPropertiesTicketInfo: RoleAssignmentScheduleRequestPropertiesTicketInfo,
    RoleAssignmentScheduleRequestListResult: RoleAssignmentScheduleRequestListResult,
    RoleEligibilitySchedule: RoleEligibilitySchedule,
    RoleEligibilityScheduleListResult: RoleEligibilityScheduleListResult,
    RoleEligibilityScheduleInstanceListResult: RoleEligibilityScheduleInstanceListResult,
    RoleEligibilityScheduleInstance: RoleEligibilityScheduleInstance,
    RoleEligibilityScheduleRequest: RoleEligibilityScheduleRequest,
    RoleEligibilityScheduleRequestPropertiesScheduleInfo: RoleEligibilityScheduleRequestPropertiesScheduleInfo,
    RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration: RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration,
    RoleEligibilityScheduleRequestPropertiesTicketInfo: RoleEligibilityScheduleRequestPropertiesTicketInfo,
    RoleEligibilityScheduleRequestListResult: RoleEligibilityScheduleRequestListResult,
    RoleManagementPolicy: RoleManagementPolicy,
    RoleManagementPolicyRule: RoleManagementPolicyRule,
    RoleManagementPolicyRuleTarget: RoleManagementPolicyRuleTarget,
    PolicyProperties: PolicyProperties,
    PolicyPropertiesScope: PolicyPropertiesScope,
    RoleManagementPolicyListResult: RoleManagementPolicyListResult,
    RoleManagementPolicyAssignment: RoleManagementPolicyAssignment,
    PolicyAssignmentProperties: PolicyAssignmentProperties,
    PolicyAssignmentPropertiesScope: PolicyAssignmentPropertiesScope,
    PolicyAssignmentPropertiesRoleDefinition: PolicyAssignmentPropertiesRoleDefinition,
    PolicyAssignmentPropertiesPolicy: PolicyAssignmentPropertiesPolicy,
    RoleManagementPolicyAssignmentListResult: RoleManagementPolicyAssignmentListResult,
    DenyAssignmentFilter: DenyAssignmentFilter,
    ValidationResponseErrorInfo: ValidationResponseErrorInfo,
    ValidationResponse: ValidationResponse,
    RoleAssignmentFilter: RoleAssignmentFilter,
    RoleDefinitionFilter: RoleDefinitionFilter,
    ApprovalSettings: ApprovalSettings,
    ApprovalStage: ApprovalStage,
    UserSet: UserSet,
    RoleAssignmentScheduleFilter: RoleAssignmentScheduleFilter,
    RoleAssignmentScheduleInstanceFilter: RoleAssignmentScheduleInstanceFilter,
    RoleAssignmentScheduleRequestFilter: RoleAssignmentScheduleRequestFilter,
    RoleEligibilityScheduleFilter: RoleEligibilityScheduleFilter,
    RoleEligibilityScheduleInstanceFilter: RoleEligibilityScheduleInstanceFilter,
    RoleEligibilityScheduleRequestFilter: RoleEligibilityScheduleRequestFilter,
    RoleManagementPolicyApprovalRule: RoleManagementPolicyApprovalRule,
    RoleManagementPolicyAuthenticationContextRule: RoleManagementPolicyAuthenticationContextRule,
    RoleManagementPolicyEnablementRule: RoleManagementPolicyEnablementRule,
    RoleManagementPolicyExpirationRule: RoleManagementPolicyExpirationRule,
    RoleManagementPolicyNotificationRule: RoleManagementPolicyNotificationRule,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2015-07-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceProviderNamespace = {
    parameterPath: "resourceProviderNamespace",
    mapper: {
        serializedName: "resourceProviderNamespace",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parentResourcePath = {
    parameterPath: "parentResourcePath",
    mapper: {
        serializedName: "parentResourcePath",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceType = {
    parameterPath: "resourceType",
    mapper: {
        serializedName: "resourceType",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-04-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const denyAssignmentId = {
    parameterPath: "denyAssignmentId",
    mapper: {
        serializedName: "denyAssignmentId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const denyAssignmentId1 = {
    parameterPath: "denyAssignmentId",
    mapper: {
        serializedName: "denyAssignmentId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        defaultValue: "resourceTypes",
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const tenantId = {
    parameterPath: ["options", "tenantId"],
    mapper: {
        serializedName: "tenantId",
        type: {
            name: "String"
        }
    }
};
const resourceName1 = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const roleAssignmentName = {
    parameterPath: "roleAssignmentName",
    mapper: {
        serializedName: "roleAssignmentName",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: RoleAssignmentCreateParameters
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const roleAssignmentId = {
    parameterPath: "roleAssignmentId",
    mapper: {
        serializedName: "roleAssignmentId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const roleDefinitionId = {
    parameterPath: "roleDefinitionId",
    mapper: {
        serializedName: "roleDefinitionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleDefinition = {
    parameterPath: "roleDefinition",
    mapper: RoleDefinition
};
const roleId = {
    parameterPath: "roleId",
    mapper: {
        serializedName: "roleId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion2 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const roleAssignmentScheduleName = {
    parameterPath: "roleAssignmentScheduleName",
    mapper: {
        serializedName: "roleAssignmentScheduleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleAssignmentScheduleInstanceName = {
    parameterPath: "roleAssignmentScheduleInstanceName",
    mapper: {
        serializedName: "roleAssignmentScheduleInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: RoleAssignmentScheduleRequest
};
const roleAssignmentScheduleRequestName = {
    parameterPath: "roleAssignmentScheduleRequestName",
    mapper: {
        serializedName: "roleAssignmentScheduleRequestName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleEligibilityScheduleName = {
    parameterPath: "roleEligibilityScheduleName",
    mapper: {
        serializedName: "roleEligibilityScheduleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleEligibilityScheduleInstanceName = {
    parameterPath: "roleEligibilityScheduleInstanceName",
    mapper: {
        serializedName: "roleEligibilityScheduleInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: RoleEligibilityScheduleRequest
};
const roleEligibilityScheduleRequestName = {
    parameterPath: "roleEligibilityScheduleRequestName",
    mapper: {
        serializedName: "roleEligibilityScheduleRequestName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleManagementPolicyName = {
    parameterPath: "roleManagementPolicyName",
    mapper: {
        serializedName: "roleManagementPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: RoleManagementPolicy
};
const roleManagementPolicyAssignmentName = {
    parameterPath: "roleManagementPolicyAssignmentName",
    mapper: {
        serializedName: "roleManagementPolicyAssignmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: RoleManagementPolicyAssignment
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ClassicAdministrators operations. */
class ClassicAdministratorsImpl {
    /**
     * Initialize a new instance of the class ClassicAdministrators class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets service administrator, account administrator, and co-administrators for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets service administrator, account administrator, and co-administrators for the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/classicAdministrators",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClassicAdministratorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClassicAdministratorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GlobalAdministrator operations. */
class GlobalAdministratorImpl {
    /**
     * Initialize a new instance of the class GlobalAdministrator class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Elevates access for a Global Administrator.
     * @param options The options parameters.
     */
    elevateAccess(options) {
        return this.client.sendOperationRequest({ options }, elevateAccessOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const elevateAccessOperationSpec = {
    path: "/providers/Microsoft.Authorization/elevateAccess",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DenyAssignments operations. */
class DenyAssignmentsImpl {
    /**
     * Initialize a new instance of the class DenyAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets deny assignments for a resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get deny assignments for.
     * @param options The options parameters.
     */
    listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        const iter = this.listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings);
            }
        };
    }
    listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets deny assignments for a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listForResourceGroup(resourceGroupName, options) {
        const iter = this.listForResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listForResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all deny assignments for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets deny assignments for a scope.
     * @param scope The scope of the deny assignments.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets deny assignments for a resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get deny assignments for.
     * @param options The options parameters.
     */
    _listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            options
        }, listForResourceOperationSpec$2);
    }
    /**
     * Gets deny assignments for a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listForResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listForResourceGroupOperationSpec$2);
    }
    /**
     * Gets all deny assignments for the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Get the specified deny assignment.
     * @param scope The scope of the deny assignment.
     * @param denyAssignmentId The ID of the deny assignment to get.
     * @param options The options parameters.
     */
    get(scope, denyAssignmentId, options) {
        return this.client.sendOperationRequest({ scope, denyAssignmentId, options }, getOperationSpec$c);
    }
    /**
     * Gets a deny assignment by ID.
     * @param denyAssignmentId The fully qualified deny assignment ID. For example, use the format,
     *                         /subscriptions/{guid}/providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId} for
     *                         subscription level deny assignments, or
     *                         /providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId} for tenant level deny
     *                         assignments.
     * @param options The options parameters.
     */
    getById(denyAssignmentId, options) {
        return this.client.sendOperationRequest({ denyAssignmentId, options }, getByIdOperationSpec$2);
    }
    /**
     * Gets deny assignments for a scope.
     * @param scope The scope of the deny assignments.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$9);
    }
    /**
     * ListForResourceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get deny assignments for.
     * @param nextLink The nextLink from the previous successful call to the ListForResource method.
     * @param options The options parameters.
     */
    _listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listForResourceNextOperationSpec$2);
    }
    /**
     * ListForResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListForResourceGroup method.
     * @param options The options parameters.
     */
    _listForResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listForResourceGroupNextOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the deny assignments.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listForResourceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/denyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listForResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/denyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/denyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$c = {
    path: "/{scope}/providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        denyAssignmentId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getByIdOperationSpec$2 = {
    path: "/{denyAssignmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, denyAssignmentId1],
    headerParameters: [accept],
    serializer: serializer$d
};
const listForScopeOperationSpec$9 = {
    path: "/{scope}/providers/Microsoft.Authorization/denyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$d
};
const listForResourceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listForResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listForScopeNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DenyAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ProviderOperationsMetadataOperations operations. */
class ProviderOperationsMetadataOperationsImpl {
    /**
     * Initialize a new instance of the class ProviderOperationsMetadataOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets provider operations metadata for all resource providers.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets provider operations metadata for the specified resource provider.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param options The options parameters.
     */
    get(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, getOperationSpec$b);
    }
    /**
     * Gets provider operations metadata for all resource providers.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/providers/Microsoft.Authorization/providerOperations/{resourceProviderNamespace}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderOperationsMetadata
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [$host, resourceProviderNamespace],
    headerParameters: [accept],
    serializer: serializer$c
};
const listOperationSpec$1 = {
    path: "/providers/Microsoft.Authorization/providerOperations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderOperationsMetadataListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$c
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderOperationsMetadataListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleAssignments operations. */
class RoleAssignmentsImpl {
    /**
     * Initialize a new instance of the class RoleAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all role assignments that apply to a subscription.
     * @param options The options parameters.
     */
    listForSubscription(options) {
        const iter = this.listForSubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForSubscriptionPagingPage(options, settings);
            }
        };
    }
    listForSubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForSubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForSubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForSubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForSubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listForSubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForSubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all role assignments that apply to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listForResourceGroup(resourceGroupName, options) {
        const iter = this.listForResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listForResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all role assignments that apply to a resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The resource name.
     * @param options The options parameters.
     */
    listForResource(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options) {
        const iter = this.listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options, settings);
            }
        };
    }
    listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResource(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceNext(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * List all role assignments that apply to a scope.
     * @param scope The scope of the operation or resource. Valid scopes are: subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * List all role assignments that apply to a subscription.
     * @param options The options parameters.
     */
    _listForSubscription(options) {
        return this.client.sendOperationRequest({ options }, listForSubscriptionOperationSpec);
    }
    /**
     * List all role assignments that apply to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listForResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listForResourceGroupOperationSpec$1);
    }
    /**
     * List all role assignments that apply to a resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The resource name.
     * @param options The options parameters.
     */
    _listForResource(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            resourceType,
            resourceName,
            options
        }, listForResourceOperationSpec$1);
    }
    /**
     * Get a role assignment by scope and name.
     * @param scope The scope of the operation or resource. Valid scopes are: subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param roleAssignmentName The name of the role assignment. It can be any valid GUID.
     * @param options The options parameters.
     */
    get(scope, roleAssignmentName, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentName, options }, getOperationSpec$a);
    }
    /**
     * Create or update a role assignment by scope and name.
     * @param scope The scope of the operation or resource. Valid scopes are: subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param roleAssignmentName The name of the role assignment. It can be any valid GUID.
     * @param parameters Parameters for the role assignment.
     * @param options The options parameters.
     */
    create(scope, roleAssignmentName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentName, parameters, options }, createOperationSpec$3);
    }
    /**
     * Delete a role assignment by scope and name.
     * @param scope The scope of the operation or resource. Valid scopes are: subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param roleAssignmentName The name of the role assignment. It can be any valid GUID.
     * @param options The options parameters.
     */
    delete(scope, roleAssignmentName, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentName, options }, deleteOperationSpec$3);
    }
    /**
     * List all role assignments that apply to a scope.
     * @param scope The scope of the operation or resource. Valid scopes are: subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$8);
    }
    /**
     * Get a role assignment by ID.
     * @param roleAssignmentId The fully qualified ID of the role assignment including scope, resource
     *                         name, and resource type. Format:
     *                         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
     *                         /subscriptions/<SUB_ID>/resourcegroups/<RESOURCE_GROUP>/providers/Microsoft.Authorization/roleAssignments/<ROLE_ASSIGNMENT_NAME>
     * @param options The options parameters.
     */
    getById(roleAssignmentId, options) {
        return this.client.sendOperationRequest({ roleAssignmentId, options }, getByIdOperationSpec$1);
    }
    /**
     * Create or update a role assignment by ID.
     * @param roleAssignmentId The fully qualified ID of the role assignment including scope, resource
     *                         name, and resource type. Format:
     *                         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
     *                         /subscriptions/<SUB_ID>/resourcegroups/<RESOURCE_GROUP>/providers/Microsoft.Authorization/roleAssignments/<ROLE_ASSIGNMENT_NAME>
     * @param parameters Parameters for the role assignment.
     * @param options The options parameters.
     */
    createById(roleAssignmentId, parameters, options) {
        return this.client.sendOperationRequest({ roleAssignmentId, parameters, options }, createByIdOperationSpec);
    }
    /**
     * Delete a role assignment by ID.
     * @param roleAssignmentId The fully qualified ID of the role assignment including scope, resource
     *                         name, and resource type. Format:
     *                         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
     *                         /subscriptions/<SUB_ID>/resourcegroups/<RESOURCE_GROUP>/providers/Microsoft.Authorization/roleAssignments/<ROLE_ASSIGNMENT_NAME>
     * @param options The options parameters.
     */
    deleteById(roleAssignmentId, options) {
        return this.client.sendOperationRequest({ roleAssignmentId, options }, deleteByIdOperationSpec);
    }
    /**
     * ListForSubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListForSubscription method.
     * @param options The options parameters.
     */
    _listForSubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listForSubscriptionNextOperationSpec);
    }
    /**
     * ListForResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListForResourceGroup method.
     * @param options The options parameters.
     */
    _listForResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listForResourceGroupNextOperationSpec$1);
    }
    /**
     * ListForResourceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The resource name.
     * @param nextLink The nextLink from the previous successful call to the ListForResource method.
     * @param options The options parameters.
     */
    _listForResourceNext(resourceGroupName, resourceProviderNamespace, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listForResourceNextOperationSpec$1);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the operation or resource. Valid scopes are: subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listForSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion1,
        filter1,
        tenantId
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion1,
        filter1,
        tenantId
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForResourceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion1,
        filter1,
        tenantId
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        resourceType,
        resourceName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$a = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, tenantId],
    urlParameters: [
        $host,
        scope,
        roleAssignmentName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RoleAssignment
        },
        201: {
            bodyMapper: RoleAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        roleAssignmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: RoleAssignment
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, tenantId],
    urlParameters: [
        $host,
        scope,
        roleAssignmentName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForScopeOperationSpec$8 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion1,
        filter1,
        tenantId,
        skipToken
    ],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$b
};
const getByIdOperationSpec$1 = {
    path: "/{roleAssignmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, tenantId],
    urlParameters: [$host, roleAssignmentId],
    headerParameters: [accept],
    serializer: serializer$b
};
const createByIdOperationSpec = {
    path: "/{roleAssignmentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RoleAssignment
        },
        201: {
            bodyMapper: RoleAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion1],
    urlParameters: [$host, roleAssignmentId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteByIdOperationSpec = {
    path: "/{roleAssignmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: RoleAssignment
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, tenantId],
    urlParameters: [$host, roleAssignmentId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForSubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForResourceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        resourceProviderNamespace,
        resourceType,
        resourceName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listForScopeNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Permissions operations. */
class PermissionsImpl {
    /**
     * Initialize a new instance of the class Permissions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all permissions the caller has for a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listForResourceGroup(resourceGroupName, options) {
        const iter = this.listForResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listForResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all permissions the caller has for a resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get the permissions for.
     * @param options The options parameters.
     */
    listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        const iter = this.listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings);
            }
        };
    }
    listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all permissions the caller has for a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listForResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listForResourceGroupOperationSpec);
    }
    /**
     * Gets all permissions the caller has for a resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get the permissions for.
     * @param options The options parameters.
     */
    _listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            options
        }, listForResourceOperationSpec);
    }
    /**
     * ListForResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListForResourceGroup method.
     * @param options The options parameters.
     */
    _listForResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listForResourceGroupNextOperationSpec);
    }
    /**
     * ListForResourceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get the permissions for.
     * @param nextLink The nextLink from the previous successful call to the ListForResource method.
     * @param options The options parameters.
     */
    _listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listForResourceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listForResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Authorization/permissions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PermissionGetResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listForResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/permissions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PermissionGetResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listForResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PermissionGetResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listForResourceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PermissionGetResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleDefinitions operations. */
class RoleDefinitionsImpl {
    /**
     * Initialize a new instance of the class RoleDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all role definitions that are applicable at scope and above.
     * @param scope The scope of the role definition.
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.listPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(scope, options, settings);
            }
        };
    }
    listPagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes a role definition.
     * @param scope The scope of the role definition.
     * @param roleDefinitionId The ID of the role definition to delete.
     * @param options The options parameters.
     */
    delete(scope, roleDefinitionId, options) {
        return this.client.sendOperationRequest({ scope, roleDefinitionId, options }, deleteOperationSpec$2);
    }
    /**
     * Get role definition by name (GUID).
     * @param scope The scope of the role definition.
     * @param roleDefinitionId The ID of the role definition.
     * @param options The options parameters.
     */
    get(scope, roleDefinitionId, options) {
        return this.client.sendOperationRequest({ scope, roleDefinitionId, options }, getOperationSpec$9);
    }
    /**
     * Creates or updates a role definition.
     * @param scope The scope of the role definition.
     * @param roleDefinitionId The ID of the role definition.
     * @param roleDefinition The values for the role definition.
     * @param options The options parameters.
     */
    createOrUpdate(scope, roleDefinitionId, roleDefinition, options) {
        return this.client.sendOperationRequest({ scope, roleDefinitionId, roleDefinition, options }, createOrUpdateOperationSpec);
    }
    /**
     * Get all role definitions that are applicable at scope and above.
     * @param scope The scope of the role definition.
     * @param options The options parameters.
     */
    _list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec);
    }
    /**
     * Gets a role definition by ID.
     * @param roleId The fully qualified role definition ID. Use the format,
     *               /subscriptions/{guid}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for
     *               subscription level role definitions, or
     *               /providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for tenant level role
     *               definitions.
     * @param options The options parameters.
     */
    getById(roleId, options) {
        return this.client.sendOperationRequest({ roleId, options }, getByIdOperationSpec);
    }
    /**
     * ListNext
     * @param scope The scope of the role definition.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: RoleDefinition
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        roleDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$9 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        roleDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: RoleDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: roleDefinition,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        roleDefinitionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleDefinitionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$9
};
const getByIdOperationSpec = {
    path: "/{roleId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, roleId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleDefinitionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EligibleChildResources operations. */
class EligibleChildResourcesImpl {
    /**
     * Initialize a new instance of the class EligibleChildResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the child resources of a resource on which user has eligible access
     * @param scope The scope of the role management policy.
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.getPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPagingPage(scope, options, settings);
            }
        };
    }
    getPagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._get(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the child resources of a resource on which user has eligible access
     * @param scope The scope of the role management policy.
     * @param options The options parameters.
     */
    _get(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, getOperationSpec$8);
    }
    /**
     * GetNext
     * @param scope The scope of the role management policy.
     * @param nextLink The nextLink from the previous successful call to the Get method.
     * @param options The options parameters.
     */
    _getNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, getNextOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/{scope}/providers/Microsoft.Authorization/eligibleChildResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EligibleChildResourcesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$8
};
const getNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EligibleChildResourcesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleAssignmentSchedules operations. */
class RoleAssignmentSchedulesImpl {
    /**
     * Initialize a new instance of the class RoleAssignmentSchedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role assignment schedules for a resource scope.
     * @param scope The scope of the role assignments schedules.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the specified role assignment schedule for a resource scope
     * @param scope The scope of the role assignment schedule.
     * @param roleAssignmentScheduleName The name (guid) of the role assignment schedule to get.
     * @param options The options parameters.
     */
    get(scope, roleAssignmentScheduleName, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentScheduleName, options }, getOperationSpec$7);
    }
    /**
     * Gets role assignment schedules for a resource scope.
     * @param scope The scope of the role assignments schedules.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$7);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role assignments schedules.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentSchedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleAssignmentScheduleName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listForScopeOperationSpec$7 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$7
};
const listForScopeNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleAssignmentScheduleInstances operations. */
class RoleAssignmentScheduleInstancesImpl {
    /**
     * Initialize a new instance of the class RoleAssignmentScheduleInstances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role assignment schedule instances of a role assignment schedule.
     * @param scope The scope of the role assignment schedule.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets role assignment schedule instances of a role assignment schedule.
     * @param scope The scope of the role assignment schedule.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$6);
    }
    /**
     * Gets the specified role assignment schedule instance.
     * @param scope The scope of the role assignments schedules.
     * @param roleAssignmentScheduleInstanceName The name (hash of schedule name + time) of the role
     *                                           assignment schedule to get.
     * @param options The options parameters.
     */
    get(scope, roleAssignmentScheduleInstanceName, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentScheduleInstanceName, options }, getOperationSpec$6);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role assignment schedule.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listForScopeOperationSpec$6 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleInstanceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$6 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleInstances/{roleAssignmentScheduleInstanceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleInstance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleAssignmentScheduleInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listForScopeNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleInstanceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleAssignmentScheduleRequests operations. */
class RoleAssignmentScheduleRequestsImpl {
    /**
     * Initialize a new instance of the class RoleAssignmentScheduleRequests class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role assignment schedule requests for a scope.
     * @param scope The scope of the role assignments schedule requests.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a role assignment schedule request.
     * @param scope The scope of the role assignment schedule request to create. The scope can be any REST
     *              resource instance. For example, use '/subscriptions/{subscription-id}/' for a subscription,
     *              '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a resource group, and
     *              '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
     *              for a resource.
     * @param roleAssignmentScheduleRequestName A GUID for the role assignment to create. The name must be
     *                                          unique and different for each role assignment.
     * @param parameters Parameters for the role assignment schedule request.
     * @param options The options parameters.
     */
    create(scope, roleAssignmentScheduleRequestName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentScheduleRequestName, parameters, options }, createOperationSpec$2);
    }
    /**
     * Get the specified role assignment schedule request.
     * @param scope The scope of the role assignment schedule request.
     * @param roleAssignmentScheduleRequestName The name (guid) of the role assignment schedule request to
     *                                          get.
     * @param options The options parameters.
     */
    get(scope, roleAssignmentScheduleRequestName, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentScheduleRequestName, options }, getOperationSpec$5);
    }
    /**
     * Gets role assignment schedule requests for a scope.
     * @param scope The scope of the role assignments schedule requests.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$5);
    }
    /**
     * Cancels a pending role assignment schedule request.
     * @param scope The scope of the role assignment request to cancel.
     * @param roleAssignmentScheduleRequestName The name of the role assignment request to cancel.
     * @param options The options parameters.
     */
    cancel(scope, roleAssignmentScheduleRequestName, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentScheduleRequestName, options }, cancelOperationSpec$1);
    }
    /**
     * Validates a new role assignment schedule request.
     * @param scope The scope of the role assignment request to validate.
     * @param roleAssignmentScheduleRequestName The name of the role assignment request to validate.
     * @param parameters Parameters for the role assignment schedule request.
     * @param options The options parameters.
     */
    validate(scope, roleAssignmentScheduleRequestName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleAssignmentScheduleRequestName, parameters, options }, validateOperationSpec$1);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role assignments schedule requests.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: RoleAssignmentScheduleRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleAssignmentScheduleRequestName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const getOperationSpec$5 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleAssignmentScheduleRequestName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listForScopeOperationSpec$5 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleRequestListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$5
};
const cancelOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleAssignmentScheduleRequestName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const validateOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleAssignmentScheduleRequestName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listForScopeNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentScheduleRequestListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleEligibilitySchedules operations. */
class RoleEligibilitySchedulesImpl {
    /**
     * Initialize a new instance of the class RoleEligibilitySchedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role eligibility schedules for a resource scope.
     * @param scope The scope of the role eligibility schedules.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the specified role eligibility schedule for a resource scope
     * @param scope The scope of the role eligibility schedule.
     * @param roleEligibilityScheduleName The name (guid) of the role eligibility schedule to get.
     * @param options The options parameters.
     */
    get(scope, roleEligibilityScheduleName, options) {
        return this.client.sendOperationRequest({ scope, roleEligibilityScheduleName, options }, getOperationSpec$4);
    }
    /**
     * Gets role eligibility schedules for a resource scope.
     * @param scope The scope of the role eligibility schedules.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$4);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role eligibility schedules.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilitySchedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleEligibilityScheduleName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listForScopeOperationSpec$4 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$4
};
const listForScopeNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleEligibilityScheduleInstances operations. */
class RoleEligibilityScheduleInstancesImpl {
    /**
     * Initialize a new instance of the class RoleEligibilityScheduleInstances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role eligibility schedule instances of a role eligibility schedule.
     * @param scope The scope of the role eligibility schedule.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets role eligibility schedule instances of a role eligibility schedule.
     * @param scope The scope of the role eligibility schedule.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$3);
    }
    /**
     * Gets the specified role eligibility schedule instance.
     * @param scope The scope of the role eligibility schedules.
     * @param roleEligibilityScheduleInstanceName The name (hash of schedule name + time) of the role
     *                                            eligibility schedule to get.
     * @param options The options parameters.
     */
    get(scope, roleEligibilityScheduleInstanceName, options) {
        return this.client.sendOperationRequest({ scope, roleEligibilityScheduleInstanceName, options }, getOperationSpec$3);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role eligibility schedule.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listForScopeOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleInstanceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleInstance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleEligibilityScheduleInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listForScopeNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleInstanceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleEligibilityScheduleRequests operations. */
class RoleEligibilityScheduleRequestsImpl {
    /**
     * Initialize a new instance of the class RoleEligibilityScheduleRequests class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role eligibility schedule requests for a scope.
     * @param scope The scope of the role eligibility schedule requests.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a role eligibility schedule request.
     * @param scope The scope of the role eligibility schedule request to create. The scope can be any REST
     *              resource instance. For example, use '/subscriptions/{subscription-id}/' for a subscription,
     *              '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a resource group, and
     *              '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
     *              for a resource.
     * @param roleEligibilityScheduleRequestName The name of the role eligibility to create. It can be any
     *                                           valid GUID.
     * @param parameters Parameters for the role eligibility schedule request.
     * @param options The options parameters.
     */
    create(scope, roleEligibilityScheduleRequestName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleEligibilityScheduleRequestName, parameters, options }, createOperationSpec$1);
    }
    /**
     * Get the specified role eligibility schedule request.
     * @param scope The scope of the role eligibility schedule request.
     * @param roleEligibilityScheduleRequestName The name (guid) of the role eligibility schedule request
     *                                           to get.
     * @param options The options parameters.
     */
    get(scope, roleEligibilityScheduleRequestName, options) {
        return this.client.sendOperationRequest({ scope, roleEligibilityScheduleRequestName, options }, getOperationSpec$2);
    }
    /**
     * Gets role eligibility schedule requests for a scope.
     * @param scope The scope of the role eligibility schedule requests.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$2);
    }
    /**
     * Cancels a pending role eligibility schedule request.
     * @param scope The scope of the role eligibility request to cancel.
     * @param roleEligibilityScheduleRequestName The name of the role eligibility request to cancel.
     * @param options The options parameters.
     */
    cancel(scope, roleEligibilityScheduleRequestName, options) {
        return this.client.sendOperationRequest({ scope, roleEligibilityScheduleRequestName, options }, cancelOperationSpec);
    }
    /**
     * Validates a new role eligibility schedule request.
     * @param scope The scope of the role eligibility request to validate.
     * @param roleEligibilityScheduleRequestName The name of the role eligibility request to validate.
     * @param parameters Parameters for the role eligibility schedule request.
     * @param options The options parameters.
     */
    validate(scope, roleEligibilityScheduleRequestName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleEligibilityScheduleRequestName, parameters, options }, validateOperationSpec);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role eligibility schedule requests.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: RoleEligibilityScheduleRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleEligibilityScheduleRequestName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleEligibilityScheduleRequestName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listForScopeOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleRequestListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$2
};
const cancelOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleEligibilityScheduleRequestName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const validateOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleEligibilityScheduleRequestName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listForScopeNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleEligibilityScheduleRequestListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleManagementPolicies operations. */
class RoleManagementPoliciesImpl {
    /**
     * Initialize a new instance of the class RoleManagementPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role management policies for a resource scope.
     * @param scope The scope of the role management policy.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the specified role management policy for a resource scope
     * @param scope The scope of the role management policy.
     * @param roleManagementPolicyName The name (guid) of the role management policy to get.
     * @param options The options parameters.
     */
    get(scope, roleManagementPolicyName, options) {
        return this.client.sendOperationRequest({ scope, roleManagementPolicyName, options }, getOperationSpec$1);
    }
    /**
     * Update a role management policy
     * @param scope The scope of the role management policy to upsert.
     * @param roleManagementPolicyName The name (guid) of the role management policy to upsert.
     * @param parameters Parameters for the role management policy.
     * @param options The options parameters.
     */
    update(scope, roleManagementPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleManagementPolicyName, parameters, options }, updateOperationSpec);
    }
    /**
     * Delete a role management policy
     * @param scope The scope of the role management policy to upsert.
     * @param roleManagementPolicyName The name (guid) of the role management policy to upsert.
     * @param options The options parameters.
     */
    delete(scope, roleManagementPolicyName, options) {
        return this.client.sendOperationRequest({ scope, roleManagementPolicyName, options }, deleteOperationSpec$1);
    }
    /**
     * Gets role management policies for a resource scope.
     * @param scope The scope of the role management policy.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec$1);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role management policy.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleManagementPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleManagementPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleManagementPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listForScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$1
};
const listForScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleManagementPolicyAssignments operations. */
class RoleManagementPolicyAssignmentsImpl {
    /**
     * Initialize a new instance of the class RoleManagementPolicyAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets role management assignment policies for a resource scope.
     * @param scope The scope of the role management policy.
     * @param options The options parameters.
     */
    listForScope(scope, options) {
        const iter = this.listForScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForScopePagingPage(scope, options, settings);
            }
        };
    }
    listForScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listForScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the specified role management policy assignment for a resource scope
     * @param scope The scope of the role management policy.
     * @param roleManagementPolicyAssignmentName The name of format {guid_guid} the role management policy
     *                                           assignment to get.
     * @param options The options parameters.
     */
    get(scope, roleManagementPolicyAssignmentName, options) {
        return this.client.sendOperationRequest({ scope, roleManagementPolicyAssignmentName, options }, getOperationSpec);
    }
    /**
     * Create a role management policy assignment
     * @param scope The scope of the role management policy assignment to upsert.
     * @param roleManagementPolicyAssignmentName The name of format {guid_guid} the role management policy
     *                                           assignment to upsert.
     * @param parameters Parameters for the role management policy assignment.
     * @param options The options parameters.
     */
    create(scope, roleManagementPolicyAssignmentName, parameters, options) {
        return this.client.sendOperationRequest({ scope, roleManagementPolicyAssignmentName, parameters, options }, createOperationSpec);
    }
    /**
     * Delete a role management policy assignment
     * @param scope The scope of the role management policy assignment to delete.
     * @param roleManagementPolicyAssignmentName The name of format {guid_guid} the role management policy
     *                                           assignment to delete.
     * @param options The options parameters.
     */
    delete(scope, roleManagementPolicyAssignmentName, options) {
        return this.client.sendOperationRequest({ scope, roleManagementPolicyAssignmentName, options }, deleteOperationSpec);
    }
    /**
     * Gets role management assignment policies for a resource scope.
     * @param scope The scope of the role management policy.
     * @param options The options parameters.
     */
    _listForScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listForScopeOperationSpec);
    }
    /**
     * ListForScopeNext
     * @param scope The scope of the role management policy.
     * @param nextLink The nextLink from the previous successful call to the ListForScope method.
     * @param options The options parameters.
     */
    _listForScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listForScopeNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleManagementPolicyAssignmentName
    ],
    headerParameters: [accept],
    serializer
};
const createOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: RoleManagementPolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleManagementPolicyAssignmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        roleManagementPolicyAssignmentName
    ],
    headerParameters: [accept],
    serializer
};
const listForScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer
};
const listForScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleManagementPolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class AuthorizationManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the AuthorizationManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-authorization/9.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.classicAdministrators = new ClassicAdministratorsImpl(this);
        this.globalAdministrator = new GlobalAdministratorImpl(this);
        this.denyAssignments = new DenyAssignmentsImpl(this);
        this.providerOperationsMetadataOperations = new ProviderOperationsMetadataOperationsImpl(this);
        this.roleAssignments = new RoleAssignmentsImpl(this);
        this.permissions = new PermissionsImpl(this);
        this.roleDefinitions = new RoleDefinitionsImpl(this);
        this.eligibleChildResources = new EligibleChildResourcesImpl(this);
        this.roleAssignmentSchedules = new RoleAssignmentSchedulesImpl(this);
        this.roleAssignmentScheduleInstances = new RoleAssignmentScheduleInstancesImpl(this);
        this.roleAssignmentScheduleRequests = new RoleAssignmentScheduleRequestsImpl(this);
        this.roleEligibilitySchedules = new RoleEligibilitySchedulesImpl(this);
        this.roleEligibilityScheduleInstances = new RoleEligibilityScheduleInstancesImpl(this);
        this.roleEligibilityScheduleRequests = new RoleEligibilityScheduleRequestsImpl(this);
        this.roleManagementPolicies = new RoleManagementPoliciesImpl(this);
        this.roleManagementPolicyAssignments = new RoleManagementPolicyAssignmentsImpl(this);
    }
}

exports.AuthorizationManagementClient = AuthorizationManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
