'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var tslib = require('tslib');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link AliasPathTokenType} that the service accepts. */
exports.KnownAliasPathTokenType = void 0;
(function (KnownAliasPathTokenType) {
    /** The token type is not specified. */
    KnownAliasPathTokenType["NotSpecified"] = "NotSpecified";
    /** The token type can be anything. */
    KnownAliasPathTokenType["Any"] = "Any";
    /** The token type is string. */
    KnownAliasPathTokenType["String"] = "String";
    /** The token type is object. */
    KnownAliasPathTokenType["Object"] = "Object";
    /** The token type is array. */
    KnownAliasPathTokenType["Array"] = "Array";
    /** The token type is integer. */
    KnownAliasPathTokenType["Integer"] = "Integer";
    /** The token type is number. */
    KnownAliasPathTokenType["Number"] = "Number";
    /** The token type is boolean. */
    KnownAliasPathTokenType["Boolean"] = "Boolean";
})(exports.KnownAliasPathTokenType || (exports.KnownAliasPathTokenType = {}));
/** Known values of {@link AliasPathAttributes} that the service accepts. */
exports.KnownAliasPathAttributes = void 0;
(function (KnownAliasPathAttributes) {
    /** The token that the alias path is referring to has no attributes. */
    KnownAliasPathAttributes["None"] = "None";
    /** The token that the alias path is referring to is modifiable by policies with 'modify' effect. */
    KnownAliasPathAttributes["Modifiable"] = "Modifiable";
})(exports.KnownAliasPathAttributes || (exports.KnownAliasPathAttributes = {}));
/** Known values of {@link EnforcementMode} that the service accepts. */
exports.KnownEnforcementMode = void 0;
(function (KnownEnforcementMode) {
    /** The policy effect is enforced during resource creation or update. */
    KnownEnforcementMode["Default"] = "Default";
    /** The policy effect is not enforced during resource creation or update. */
    KnownEnforcementMode["DoNotEnforce"] = "DoNotEnforce";
})(exports.KnownEnforcementMode || (exports.KnownEnforcementMode = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link PolicyType} that the service accepts. */
exports.KnownPolicyType = void 0;
(function (KnownPolicyType) {
    /** NotSpecified */
    KnownPolicyType["NotSpecified"] = "NotSpecified";
    /** BuiltIn */
    KnownPolicyType["BuiltIn"] = "BuiltIn";
    /** Custom */
    KnownPolicyType["Custom"] = "Custom";
    /** Static */
    KnownPolicyType["Static"] = "Static";
})(exports.KnownPolicyType || (exports.KnownPolicyType = {}));
/** Known values of {@link ParameterType} that the service accepts. */
exports.KnownParameterType = void 0;
(function (KnownParameterType) {
    /** String */
    KnownParameterType["String"] = "String";
    /** Array */
    KnownParameterType["Array"] = "Array";
    /** Object */
    KnownParameterType["Object"] = "Object";
    /** Boolean */
    KnownParameterType["Boolean"] = "Boolean";
    /** Integer */
    KnownParameterType["Integer"] = "Integer";
    /** Float */
    KnownParameterType["Float"] = "Float";
    /** DateTime */
    KnownParameterType["DateTime"] = "DateTime";
})(exports.KnownParameterType || (exports.KnownParameterType = {}));
/** Known values of {@link ExemptionCategory} that the service accepts. */
exports.KnownExemptionCategory = void 0;
(function (KnownExemptionCategory) {
    /** This category of exemptions usually means the scope is not applicable for the policy. */
    KnownExemptionCategory["Waiver"] = "Waiver";
    /** This category of exemptions usually means the mitigation actions have been applied to the scope. */
    KnownExemptionCategory["Mitigated"] = "Mitigated";
})(exports.KnownExemptionCategory || (exports.KnownExemptionCategory = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const DataPolicyManifest = {
    type: {
        name: "Composite",
        className: "DataPolicyManifest",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            namespaces: {
                serializedName: "properties.namespaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            policyMode: {
                serializedName: "properties.policyMode",
                type: {
                    name: "String"
                }
            },
            isBuiltInOnly: {
                serializedName: "properties.isBuiltInOnly",
                type: {
                    name: "Boolean"
                }
            },
            resourceTypeAliases: {
                serializedName: "properties.resourceTypeAliases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceTypeAliases"
                        }
                    }
                }
            },
            effects: {
                serializedName: "properties.effects",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataEffect"
                        }
                    }
                }
            },
            fieldValues: {
                serializedName: "properties.fieldValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            standard: {
                serializedName: "properties.resourceFunctions.standard",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            custom: {
                serializedName: "properties.resourceFunctions.custom",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataManifestCustomResourceFunctionDefinition"
                        }
                    }
                }
            }
        }
    }
};
const ResourceTypeAliases = {
    type: {
        name: "Composite",
        className: "ResourceTypeAliases",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            aliases: {
                serializedName: "aliases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Alias"
                        }
                    }
                }
            }
        }
    }
};
const Alias = {
    type: {
        name: "Composite",
        className: "Alias",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            paths: {
                serializedName: "paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AliasPath"
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "PlainText", "Mask"]
                }
            },
            defaultPath: {
                serializedName: "defaultPath",
                type: {
                    name: "String"
                }
            },
            defaultPattern: {
                serializedName: "defaultPattern",
                type: {
                    name: "Composite",
                    className: "AliasPattern"
                }
            },
            defaultMetadata: {
                serializedName: "defaultMetadata",
                type: {
                    name: "Composite",
                    className: "AliasPathMetadata"
                }
            }
        }
    }
};
const AliasPath = {
    type: {
        name: "Composite",
        className: "AliasPath",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            apiVersions: {
                serializedName: "apiVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            pattern: {
                serializedName: "pattern",
                type: {
                    name: "Composite",
                    className: "AliasPattern"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Composite",
                    className: "AliasPathMetadata"
                }
            }
        }
    }
};
const AliasPattern = {
    type: {
        name: "Composite",
        className: "AliasPattern",
        modelProperties: {
            phrase: {
                serializedName: "phrase",
                type: {
                    name: "String"
                }
            },
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "Extract"]
                }
            }
        }
    }
};
const AliasPathMetadata = {
    type: {
        name: "Composite",
        className: "AliasPathMetadata",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataEffect = {
    type: {
        name: "Composite",
        className: "DataEffect",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            detailsSchema: {
                serializedName: "detailsSchema",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const DataManifestCustomResourceFunctionDefinition = {
    type: {
        name: "Composite",
        className: "DataManifestCustomResourceFunctionDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            fullyQualifiedResourceType: {
                serializedName: "fullyQualifiedResourceType",
                type: {
                    name: "String"
                }
            },
            defaultProperties: {
                serializedName: "defaultProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowCustomProperties: {
                serializedName: "allowCustomProperties",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "any"
                }
            }
        }
    }
};
const DataPolicyManifestListResult = {
    type: {
        name: "Composite",
        className: "DataPolicyManifestListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataPolicyManifest"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyAssignment = {
    type: {
        name: "Composite",
        className: "PolicyAssignment",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            policyDefinitionId: {
                serializedName: "properties.policyDefinitionId",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            notScopes: {
                serializedName: "properties.notScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParameterValuesValue" }
                    }
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            },
            enforcementMode: {
                defaultValue: "Default",
                serializedName: "properties.enforcementMode",
                type: {
                    name: "String"
                }
            },
            nonComplianceMessages: {
                serializedName: "properties.nonComplianceMessages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NonComplianceMessage"
                        }
                    }
                }
            }
        }
    }
};
const ParameterValuesValue = {
    type: {
        name: "Composite",
        className: "ParameterValuesValue",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const NonComplianceMessage = {
    type: {
        name: "Composite",
        className: "NonComplianceMessage",
        modelProperties: {
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            policyDefinitionReferenceId: {
                serializedName: "policyDefinitionReferenceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["SystemAssigned", "UserAssigned", "None"]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentitiesValue = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentitiesValue",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const PolicyAssignmentUpdate = {
    type: {
        name: "Composite",
        className: "PolicyAssignmentUpdate",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }
        }
    }
};
const PolicyAssignmentListResult = {
    type: {
        name: "Composite",
        className: "PolicyAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyAssignment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyDefinition = {
    type: {
        name: "Composite",
        className: "PolicyDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            policyType: {
                serializedName: "properties.policyType",
                type: {
                    name: "String"
                }
            },
            mode: {
                defaultValue: "Indexed",
                serializedName: "properties.mode",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            policyRule: {
                serializedName: "properties.policyRule",
                type: {
                    name: "any"
                }
            },
            metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            },
            parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParameterDefinitionsValue" }
                    }
                }
            }
        }
    }
};
const ParameterDefinitionsValue = {
    type: {
        name: "Composite",
        className: "ParameterDefinitionsValue",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            allowedValues: {
                serializedName: "allowedValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "any"
                        }
                    }
                }
            },
            defaultValue: {
                serializedName: "defaultValue",
                type: {
                    name: "any"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Composite",
                    className: "ParameterDefinitionsValueMetadata"
                }
            }
        }
    }
};
const ParameterDefinitionsValueMetadata = {
    type: {
        name: "Composite",
        className: "ParameterDefinitionsValueMetadata",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            strongType: {
                serializedName: "strongType",
                type: {
                    name: "String"
                }
            },
            assignPermissions: {
                serializedName: "assignPermissions",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PolicyDefinitionListResult = {
    type: {
        name: "Composite",
        className: "PolicyDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicySetDefinition = {
    type: {
        name: "Composite",
        className: "PolicySetDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            policyType: {
                serializedName: "properties.policyType",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            },
            parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParameterDefinitionsValue" }
                    }
                }
            },
            policyDefinitions: {
                serializedName: "properties.policyDefinitions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyDefinitionReference"
                        }
                    }
                }
            },
            policyDefinitionGroups: {
                serializedName: "properties.policyDefinitionGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyDefinitionGroup"
                        }
                    }
                }
            }
        }
    }
};
const PolicyDefinitionReference = {
    type: {
        name: "Composite",
        className: "PolicyDefinitionReference",
        modelProperties: {
            policyDefinitionId: {
                serializedName: "policyDefinitionId",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ParameterValuesValue" }
                    }
                }
            },
            policyDefinitionReferenceId: {
                serializedName: "policyDefinitionReferenceId",
                type: {
                    name: "String"
                }
            },
            groupNames: {
                serializedName: "groupNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PolicyDefinitionGroup = {
    type: {
        name: "Composite",
        className: "PolicyDefinitionGroup",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            additionalMetadataId: {
                serializedName: "additionalMetadataId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicySetDefinitionListResult = {
    type: {
        name: "Composite",
        className: "PolicySetDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicySetDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyExemption = {
    type: {
        name: "Composite",
        className: "PolicyExemption",
        modelProperties: {
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            policyAssignmentId: {
                serializedName: "properties.policyAssignmentId",
                required: true,
                type: {
                    name: "String"
                }
            },
            policyDefinitionReferenceIds: {
                serializedName: "properties.policyDefinitionReferenceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            exemptionCategory: {
                serializedName: "properties.exemptionCategory",
                required: true,
                type: {
                    name: "String"
                }
            },
            expiresOn: {
                serializedName: "properties.expiresOn",
                type: {
                    name: "DateTime"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const PolicyExemptionListResult = {
    type: {
        name: "Composite",
        className: "PolicyExemptionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyExemption"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DataPolicyManifest: DataPolicyManifest,
    ResourceTypeAliases: ResourceTypeAliases,
    Alias: Alias,
    AliasPath: AliasPath,
    AliasPattern: AliasPattern,
    AliasPathMetadata: AliasPathMetadata,
    DataEffect: DataEffect,
    DataManifestCustomResourceFunctionDefinition: DataManifestCustomResourceFunctionDefinition,
    CloudError: CloudError,
    ErrorResponse: ErrorResponse,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    DataPolicyManifestListResult: DataPolicyManifestListResult,
    PolicyAssignment: PolicyAssignment,
    ParameterValuesValue: ParameterValuesValue,
    NonComplianceMessage: NonComplianceMessage,
    Identity: Identity,
    UserAssignedIdentitiesValue: UserAssignedIdentitiesValue,
    SystemData: SystemData,
    PolicyAssignmentUpdate: PolicyAssignmentUpdate,
    PolicyAssignmentListResult: PolicyAssignmentListResult,
    PolicyDefinition: PolicyDefinition,
    ParameterDefinitionsValue: ParameterDefinitionsValue,
    ParameterDefinitionsValueMetadata: ParameterDefinitionsValueMetadata,
    PolicyDefinitionListResult: PolicyDefinitionListResult,
    PolicySetDefinition: PolicySetDefinition,
    PolicyDefinitionReference: PolicyDefinitionReference,
    PolicyDefinitionGroup: PolicyDefinitionGroup,
    PolicySetDefinitionListResult: PolicySetDefinitionListResult,
    PolicyExemption: PolicyExemption,
    PolicyExemptionListResult: PolicyExemptionListResult
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const policyMode = {
    parameterPath: "policyMode",
    mapper: {
        serializedName: "policyMode",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-09-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const policyAssignmentName = {
    parameterPath: "policyAssignmentName",
    mapper: {
        serializedName: "policyAssignmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: PolicyAssignment
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: PolicyAssignmentUpdate
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        constraints: {
            InclusiveMaximum: 1000,
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceProviderNamespace = {
    parameterPath: "resourceProviderNamespace",
    mapper: {
        serializedName: "resourceProviderNamespace",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parentResourcePath = {
    parameterPath: "parentResourcePath",
    mapper: {
        serializedName: "parentResourcePath",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceType = {
    parameterPath: "resourceType",
    mapper: {
        serializedName: "resourceType",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const managementGroupId = {
    parameterPath: "managementGroupId",
    mapper: {
        serializedName: "managementGroupId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policyAssignmentId = {
    parameterPath: "policyAssignmentId",
    mapper: {
        serializedName: "policyAssignmentId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: PolicyDefinition
};
const policyDefinitionName = {
    parameterPath: "policyDefinitionName",
    mapper: {
        serializedName: "policyDefinitionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: PolicySetDefinition
};
const policySetDefinitionName = {
    parameterPath: "policySetDefinitionName",
    mapper: {
        serializedName: "policySetDefinitionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policyExemptionName = {
    parameterPath: "policyExemptionName",
    mapper: {
        serializedName: "policyExemptionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion2 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-07-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: PolicyExemption
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataPolicyManifests operations. */
class DataPolicyManifestsImpl {
    /**
     * Initialize a new instance of the class DataPolicyManifests class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation retrieves a list of all the data policy manifests that match the optional given
     * $filter. Valid values for $filter are: "$filter=namespace eq '{0}'". If $filter is not provided, the
     * unfiltered list includes all data policy manifests for data resource types. If $filter=namespace is
     * provided, the returned list only includes all data policy manifests that have a namespace matching
     * the provided value.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation retrieves the data policy manifest with the given policy mode.
     * @param policyMode The policy mode of the data policy manifest to get.
     * @param options The options parameters.
     */
    getByPolicyMode(policyMode, options) {
        return this.client.sendOperationRequest({ policyMode, options }, getByPolicyModeOperationSpec);
    }
    /**
     * This operation retrieves a list of all the data policy manifests that match the optional given
     * $filter. Valid values for $filter are: "$filter=namespace eq '{0}'". If $filter is not provided, the
     * unfiltered list includes all data policy manifests for data resource types. If $filter=namespace is
     * provided, the returned list only includes all data policy manifests that have a namespace matching
     * the provided value.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getByPolicyModeOperationSpec = {
    path: "/providers/Microsoft.Authorization/dataPolicyManifests/{policyMode}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataPolicyManifest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, policyMode],
    headerParameters: [accept],
    serializer: serializer$4
};
const listOperationSpec$4 = {
    path: "/providers/Microsoft.Authorization/dataPolicyManifests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataPolicyManifestListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataPolicyManifestListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PolicyAssignments operations. */
class PolicyAssignmentsImpl {
    /**
     * Initialize a new instance of the class PolicyAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation retrieves the list of all policy assignments associated with the given resource group
     * in the given subscription that match the optional given $filter. Valid values for $filter are:
     * 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, the
     * unfiltered list includes all policy assignments associated with the resource group, including those
     * that apply directly or apply from containing scopes, as well as any applied to resources contained
     * within the resource group. If $filter=atScope() is provided, the returned list includes all policy
     * assignments that apply to the resource group, which is everything in the unfiltered list except
     * those applied to resources contained within the resource group. If $filter=atExactScope() is
     * provided, the returned list only includes all policy assignments that at the resource group. If
     * $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
     * assignments of the policy definition whose id is {value} that apply to the resource group.
     * @param resourceGroupName The name of the resource group that contains policy assignments.
     * @param options The options parameters.
     */
    listForResourceGroup(resourceGroupName, options) {
        const iter = this.listForResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listForResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listForResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation retrieves the list of all policy assignments associated with the specified resource
     * in the given resource group and subscription that match the optional given $filter. Valid values for
     * $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not
     * provided, the unfiltered list includes all policy assignments associated with the resource,
     * including those that apply directly or from all containing scopes, as well as any applied to
     * resources contained within the resource. If $filter=atScope() is provided, the returned list
     * includes all policy assignments that apply to the resource, which is everything in the unfiltered
     * list except those applied to resources contained within the resource. If $filter=atExactScope() is
     * provided, the returned list only includes all policy assignments that at the resource level. If
     * $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
     * assignments of the policy definition whose id is {value} that apply to the resource. Three
     * parameters plus the resource name are used to identify a specific resource. If the resource is not
     * part of a parent resource (the more common case), the parent resource path should not be provided
     * (or provided as ''). For example a web app could be specified as ({resourceProviderNamespace} ==
     * 'Microsoft.Web', {parentResourcePath} == '', {resourceType} == 'sites', {resourceName} ==
     * 'MyWebApp'). If the resource is part of a parent resource, then all parameters should be provided.
     * For example a virtual machine DNS name could be specified as ({resourceProviderNamespace} ==
     * 'Microsoft.Compute', {parentResourcePath} == 'virtualMachines/MyVirtualMachine', {resourceType} ==
     * 'domainNames', {resourceName} == 'MyComputerName'). A convenient alternative to providing the
     * namespace and type name separately is to provide both in the {resourceType} parameter, format:
     * ({resourceProviderNamespace} == '', {parentResourcePath} == '', {resourceType} ==
     * 'Microsoft.Web/sites', {resourceName} == 'MyWebApp').
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param resourceProviderNamespace The namespace of the resource provider. For example, the namespace
     *                                  of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)
     * @param parentResourcePath The parent resource path. Use empty string if there is none.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The name of the resource.
     * @param options The options parameters.
     */
    listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        const iter = this.listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings);
            }
        };
    }
    listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * This operation retrieves the list of all policy assignments applicable to the management group that
     * match the given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()' or
     * 'policyDefinitionId eq '{value}''. If $filter=atScope() is provided, the returned list includes all
     * policy assignments that are assigned to the management group or the management group's ancestors. If
     * $filter=atExactScope() is provided, the returned list only includes all policy assignments that at
     * the management group. If $filter=policyDefinitionId eq '{value}' is provided, the returned list
     * includes all policy assignments of the policy definition whose id is {value} that apply to the
     * management group.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    listForManagementGroup(managementGroupId, options) {
        const iter = this.listForManagementGroupPagingAll(managementGroupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForManagementGroupPagingPage(managementGroupId, options, settings);
            }
        };
    }
    listForManagementGroupPagingPage(managementGroupId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForManagementGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForManagementGroup(managementGroupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForManagementGroupNext(managementGroupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForManagementGroupPagingAll(managementGroupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForManagementGroupPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listForManagementGroupPagingPage(managementGroupId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * This operation retrieves the list of all policy assignments associated with the given subscription
     * that match the optional given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()'
     * or 'policyDefinitionId eq '{value}''. If $filter is not provided, the unfiltered list includes all
     * policy assignments associated with the subscription, including those that apply directly or from
     * management groups that contain the given subscription, as well as any applied to objects contained
     * within the subscription. If $filter=atScope() is provided, the returned list includes all policy
     * assignments that apply to the subscription, which is everything in the unfiltered list except those
     * applied to objects contained within the subscription. If $filter=atExactScope() is provided, the
     * returned list only includes all policy assignments that at the subscription. If
     * $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
     * assignments of the policy definition whose id is {value}.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * This operation deletes a policy assignment, given its name and the scope it was created in. The
     * scope of a policy assignment is the part of its ID preceding
     * '/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.
     * @param scope The scope of the policy assignment. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyAssignmentName The name of the policy assignment to delete.
     * @param options The options parameters.
     */
    delete(scope, policyAssignmentName, options) {
        return this.client.sendOperationRequest({ scope, policyAssignmentName, options }, deleteOperationSpec$3);
    }
    /**
     *  This operation creates or updates a policy assignment with the given scope and name. Policy
     * assignments apply to all resources contained within their scope. For example, when you assign a
     * policy at resource group scope, that policy applies to all resources in the group.
     * @param scope The scope of the policy assignment. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyAssignmentName The name of the policy assignment.
     * @param parameters Parameters for the policy assignment.
     * @param options The options parameters.
     */
    create(scope, policyAssignmentName, parameters, options) {
        return this.client.sendOperationRequest({ scope, policyAssignmentName, parameters, options }, createOperationSpec);
    }
    /**
     * This operation retrieves a single policy assignment, given its name and the scope it was created at.
     * @param scope The scope of the policy assignment. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyAssignmentName The name of the policy assignment to get.
     * @param options The options parameters.
     */
    get(scope, policyAssignmentName, options) {
        return this.client.sendOperationRequest({ scope, policyAssignmentName, options }, getOperationSpec$3);
    }
    /**
     *  This operation updates a policy assignment with the given scope and name. Policy assignments apply
     * to all resources contained within their scope. For example, when you assign a policy at resource
     * group scope, that policy applies to all resources in the group.
     * @param scope The scope of the policy assignment. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyAssignmentName The name of the policy assignment.
     * @param parameters Parameters for policy assignment patch request.
     * @param options The options parameters.
     */
    update(scope, policyAssignmentName, parameters, options) {
        return this.client.sendOperationRequest({ scope, policyAssignmentName, parameters, options }, updateOperationSpec);
    }
    /**
     * This operation retrieves the list of all policy assignments associated with the given resource group
     * in the given subscription that match the optional given $filter. Valid values for $filter are:
     * 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, the
     * unfiltered list includes all policy assignments associated with the resource group, including those
     * that apply directly or apply from containing scopes, as well as any applied to resources contained
     * within the resource group. If $filter=atScope() is provided, the returned list includes all policy
     * assignments that apply to the resource group, which is everything in the unfiltered list except
     * those applied to resources contained within the resource group. If $filter=atExactScope() is
     * provided, the returned list only includes all policy assignments that at the resource group. If
     * $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
     * assignments of the policy definition whose id is {value} that apply to the resource group.
     * @param resourceGroupName The name of the resource group that contains policy assignments.
     * @param options The options parameters.
     */
    _listForResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listForResourceGroupOperationSpec$1);
    }
    /**
     * This operation retrieves the list of all policy assignments associated with the specified resource
     * in the given resource group and subscription that match the optional given $filter. Valid values for
     * $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not
     * provided, the unfiltered list includes all policy assignments associated with the resource,
     * including those that apply directly or from all containing scopes, as well as any applied to
     * resources contained within the resource. If $filter=atScope() is provided, the returned list
     * includes all policy assignments that apply to the resource, which is everything in the unfiltered
     * list except those applied to resources contained within the resource. If $filter=atExactScope() is
     * provided, the returned list only includes all policy assignments that at the resource level. If
     * $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
     * assignments of the policy definition whose id is {value} that apply to the resource. Three
     * parameters plus the resource name are used to identify a specific resource. If the resource is not
     * part of a parent resource (the more common case), the parent resource path should not be provided
     * (or provided as ''). For example a web app could be specified as ({resourceProviderNamespace} ==
     * 'Microsoft.Web', {parentResourcePath} == '', {resourceType} == 'sites', {resourceName} ==
     * 'MyWebApp'). If the resource is part of a parent resource, then all parameters should be provided.
     * For example a virtual machine DNS name could be specified as ({resourceProviderNamespace} ==
     * 'Microsoft.Compute', {parentResourcePath} == 'virtualMachines/MyVirtualMachine', {resourceType} ==
     * 'domainNames', {resourceName} == 'MyComputerName'). A convenient alternative to providing the
     * namespace and type name separately is to provide both in the {resourceType} parameter, format:
     * ({resourceProviderNamespace} == '', {parentResourcePath} == '', {resourceType} ==
     * 'Microsoft.Web/sites', {resourceName} == 'MyWebApp').
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param resourceProviderNamespace The namespace of the resource provider. For example, the namespace
     *                                  of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)
     * @param parentResourcePath The parent resource path. Use empty string if there is none.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The name of the resource.
     * @param options The options parameters.
     */
    _listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            options
        }, listForResourceOperationSpec$1);
    }
    /**
     * This operation retrieves the list of all policy assignments applicable to the management group that
     * match the given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()' or
     * 'policyDefinitionId eq '{value}''. If $filter=atScope() is provided, the returned list includes all
     * policy assignments that are assigned to the management group or the management group's ancestors. If
     * $filter=atExactScope() is provided, the returned list only includes all policy assignments that at
     * the management group. If $filter=policyDefinitionId eq '{value}' is provided, the returned list
     * includes all policy assignments of the policy definition whose id is {value} that apply to the
     * management group.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    _listForManagementGroup(managementGroupId, options) {
        return this.client.sendOperationRequest({ managementGroupId, options }, listForManagementGroupOperationSpec$1);
    }
    /**
     * This operation retrieves the list of all policy assignments associated with the given subscription
     * that match the optional given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()'
     * or 'policyDefinitionId eq '{value}''. If $filter is not provided, the unfiltered list includes all
     * policy assignments associated with the subscription, including those that apply directly or from
     * management groups that contain the given subscription, as well as any applied to objects contained
     * within the subscription. If $filter=atScope() is provided, the returned list includes all policy
     * assignments that apply to the subscription, which is everything in the unfiltered list except those
     * applied to objects contained within the subscription. If $filter=atExactScope() is provided, the
     * returned list only includes all policy assignments that at the subscription. If
     * $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
     * assignments of the policy definition whose id is {value}.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * This operation deletes the policy with the given ID. Policy assignment IDs have this format:
     * '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid formats
     * for {scope} are: '/providers/Microsoft.Management/managementGroups/{managementGroup}' (management
     * group), '/subscriptions/{subscriptionId}' (subscription),
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' (resource group), or
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * (resource).
     * @param policyAssignmentId The ID of the policy assignment to delete. Use the format
     *                           '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.
     * @param options The options parameters.
     */
    deleteById(policyAssignmentId, options) {
        return this.client.sendOperationRequest({ policyAssignmentId, options }, deleteByIdOperationSpec);
    }
    /**
     * This operation creates or updates the policy assignment with the given ID. Policy assignments made
     * on a scope apply to all resources contained in that scope. For example, when you assign a policy to
     * a resource group that policy applies to all resources in the group. Policy assignment IDs have this
     * format: '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid
     * scopes are: management group (format:
     * '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     * '/subscriptions/{subscriptionId}'), resource group (format:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
     * @param policyAssignmentId The ID of the policy assignment to create. Use the format
     *                           '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.
     * @param parameters Parameters for policy assignment.
     * @param options The options parameters.
     */
    createById(policyAssignmentId, parameters, options) {
        return this.client.sendOperationRequest({ policyAssignmentId, parameters, options }, createByIdOperationSpec);
    }
    /**
     * The operation retrieves the policy assignment with the given ID. Policy assignment IDs have this
     * format: '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid
     * scopes are: management group (format:
     * '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     * '/subscriptions/{subscriptionId}'), resource group (format:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
     * @param policyAssignmentId The ID of the policy assignment to get. Use the format
     *                           '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.
     * @param options The options parameters.
     */
    getById(policyAssignmentId, options) {
        return this.client.sendOperationRequest({ policyAssignmentId, options }, getByIdOperationSpec);
    }
    /**
     * This operation updates the policy assignment with the given ID. Policy assignments made on a scope
     * apply to all resources contained in that scope. For example, when you assign a policy to a resource
     * group that policy applies to all resources in the group. Policy assignment IDs have this format:
     * '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid scopes
     * are: management group (format:
     * '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     * '/subscriptions/{subscriptionId}'), resource group (format:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
     * @param policyAssignmentId The ID of the policy assignment to update. Use the format
     *                           '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.
     * @param parameters Parameters for policy assignment patch request.
     * @param options The options parameters.
     */
    updateById(policyAssignmentId, parameters, options) {
        return this.client.sendOperationRequest({ policyAssignmentId, parameters, options }, updateByIdOperationSpec);
    }
    /**
     * ListForResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains policy assignments.
     * @param nextLink The nextLink from the previous successful call to the ListForResourceGroup method.
     * @param options The options parameters.
     */
    _listForResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listForResourceGroupNextOperationSpec$1);
    }
    /**
     * ListForResourceNext
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param resourceProviderNamespace The namespace of the resource provider. For example, the namespace
     *                                  of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)
     * @param parentResourcePath The parent resource path. Use empty string if there is none.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The name of the resource.
     * @param nextLink The nextLink from the previous successful call to the ListForResource method.
     * @param options The options parameters.
     */
    _listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listForResourceNextOperationSpec$1);
    }
    /**
     * ListForManagementGroupNext
     * @param managementGroupId The ID of the management group.
     * @param nextLink The nextLink from the previous successful call to the ListForManagementGroup method.
     * @param options The options parameters.
     */
    _listForManagementGroupNext(managementGroupId, nextLink, options) {
        return this.client.sendOperationRequest({ managementGroupId, nextLink, options }, listForManagementGroupNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: PolicyAssignment
        },
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        policyAssignmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: PolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        policyAssignmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        policyAssignmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        scope,
        policyAssignmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listForResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/policyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listForResourceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/policyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listForManagementGroupOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host, managementGroupId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteByIdOperationSpec = {
    path: "/{policyAssignmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: PolicyAssignment
        },
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, policyAssignmentId],
    headerParameters: [accept],
    serializer: serializer$3
};
const createByIdOperationSpec = {
    path: "/{policyAssignmentId}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: PolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion1],
    urlParameters: [$host, policyAssignmentId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getByIdOperationSpec = {
    path: "/{policyAssignmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, policyAssignmentId],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateByIdOperationSpec = {
    path: "/{policyAssignmentId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PolicyAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion1],
    urlParameters: [$host, policyAssignmentId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listForResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listForResourceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listForManagementGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PolicyDefinitions operations. */
class PolicyDefinitionsImpl {
    /**
     * Initialize a new instance of the class PolicyDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation retrieves a list of all the policy definitions in a given subscription that match the
     * optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or
     * 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all policy
     * definitions associated with the subscription, including those that apply directly or from management
     * groups that contain the given subscription. If $filter=atExactScope() is provided, the returned list
     * only includes all policy definitions that at the given subscription. If $filter='policyType -eq
     * {value}' is provided, the returned list only includes all policy definitions whose type match the
     * {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
     * $filter='category -eq {value}' is provided, the returned list only includes all policy definitions
     * whose category match the {value}.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation retrieves a list of all the built-in policy definitions that match the optional given
     * $filter. If $filter='policyType -eq {value}' is provided, the returned list only includes all
     * built-in policy definitions whose type match the {value}. Possible policyType values are
     * NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the
     * returned list only includes all built-in policy definitions whose category match the {value}.
     * @param options The options parameters.
     */
    listBuiltIn(options) {
        const iter = this.listBuiltInPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBuiltInPagingPage(options, settings);
            }
        };
    }
    listBuiltInPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBuiltInPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBuiltIn(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBuiltInNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBuiltInPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBuiltInPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBuiltInPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * This operation retrieves a list of all the policy definitions in a given management group that match
     * the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}'
     * or 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all policy
     * definitions associated with the management group, including those that apply directly or from
     * management groups that contain the given management group. If $filter=atExactScope() is provided,
     * the returned list only includes all policy definitions that at the given management group. If
     * $filter='policyType -eq {value}' is provided, the returned list only includes all policy definitions
     * whose type match the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and
     * Static. If $filter='category -eq {value}' is provided, the returned list only includes all policy
     * definitions whose category match the {value}.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    listByManagementGroup(managementGroupId, options) {
        const iter = this.listByManagementGroupPagingAll(managementGroupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByManagementGroupPagingPage(managementGroupId, options, settings);
            }
        };
    }
    listByManagementGroupPagingPage(managementGroupId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagementGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByManagementGroup(managementGroupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagementGroupNext(managementGroupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByManagementGroupPagingAll(managementGroupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagementGroupPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByManagementGroupPagingPage(managementGroupId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * This operation creates or updates a policy definition in the given subscription with the given name.
     * @param policyDefinitionName The name of the policy definition to create.
     * @param parameters The policy definition properties.
     * @param options The options parameters.
     */
    createOrUpdate(policyDefinitionName, parameters, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, parameters, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * This operation deletes the policy definition in the given subscription with the given name.
     * @param policyDefinitionName The name of the policy definition to delete.
     * @param options The options parameters.
     */
    delete(policyDefinitionName, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, options }, deleteOperationSpec$2);
    }
    /**
     * This operation retrieves the policy definition in the given subscription with the given name.
     * @param policyDefinitionName The name of the policy definition to get.
     * @param options The options parameters.
     */
    get(policyDefinitionName, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, options }, getOperationSpec$2);
    }
    /**
     * This operation retrieves the built-in policy definition with the given name.
     * @param policyDefinitionName The name of the built-in policy definition to get.
     * @param options The options parameters.
     */
    getBuiltIn(policyDefinitionName, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, options }, getBuiltInOperationSpec$1);
    }
    /**
     * This operation creates or updates a policy definition in the given management group with the given
     * name.
     * @param policyDefinitionName The name of the policy definition to create.
     * @param managementGroupId The ID of the management group.
     * @param parameters The policy definition properties.
     * @param options The options parameters.
     */
    createOrUpdateAtManagementGroup(policyDefinitionName, managementGroupId, parameters, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, managementGroupId, parameters, options }, createOrUpdateAtManagementGroupOperationSpec$1);
    }
    /**
     * This operation deletes the policy definition in the given management group with the given name.
     * @param policyDefinitionName The name of the policy definition to delete.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    deleteAtManagementGroup(policyDefinitionName, managementGroupId, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, managementGroupId, options }, deleteAtManagementGroupOperationSpec$1);
    }
    /**
     * This operation retrieves the policy definition in the given management group with the given name.
     * @param policyDefinitionName The name of the policy definition to get.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    getAtManagementGroup(policyDefinitionName, managementGroupId, options) {
        return this.client.sendOperationRequest({ policyDefinitionName, managementGroupId, options }, getAtManagementGroupOperationSpec$1);
    }
    /**
     * This operation retrieves a list of all the policy definitions in a given subscription that match the
     * optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}' or
     * 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all policy
     * definitions associated with the subscription, including those that apply directly or from management
     * groups that contain the given subscription. If $filter=atExactScope() is provided, the returned list
     * only includes all policy definitions that at the given subscription. If $filter='policyType -eq
     * {value}' is provided, the returned list only includes all policy definitions whose type match the
     * {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
     * $filter='category -eq {value}' is provided, the returned list only includes all policy definitions
     * whose category match the {value}.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * This operation retrieves a list of all the built-in policy definitions that match the optional given
     * $filter. If $filter='policyType -eq {value}' is provided, the returned list only includes all
     * built-in policy definitions whose type match the {value}. Possible policyType values are
     * NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the
     * returned list only includes all built-in policy definitions whose category match the {value}.
     * @param options The options parameters.
     */
    _listBuiltIn(options) {
        return this.client.sendOperationRequest({ options }, listBuiltInOperationSpec$1);
    }
    /**
     * This operation retrieves a list of all the policy definitions in a given management group that match
     * the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}'
     * or 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all policy
     * definitions associated with the management group, including those that apply directly or from
     * management groups that contain the given management group. If $filter=atExactScope() is provided,
     * the returned list only includes all policy definitions that at the given management group. If
     * $filter='policyType -eq {value}' is provided, the returned list only includes all policy definitions
     * whose type match the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and
     * Static. If $filter='category -eq {value}' is provided, the returned list only includes all policy
     * definitions whose category match the {value}.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    _listByManagementGroup(managementGroupId, options) {
        return this.client.sendOperationRequest({ managementGroupId, options }, listByManagementGroupOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListBuiltInNext
     * @param nextLink The nextLink from the previous successful call to the ListBuiltIn method.
     * @param options The options parameters.
     */
    _listBuiltInNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBuiltInNextOperationSpec$1);
    }
    /**
     * ListByManagementGroupNext
     * @param managementGroupId The ID of the management group.
     * @param nextLink The nextLink from the previous successful call to the ListByManagementGroup method.
     * @param options The options parameters.
     */
    _listByManagementGroupNext(managementGroupId, nextLink, options) {
        return this.client.sendOperationRequest({ managementGroupId, nextLink, options }, listByManagementGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: PolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        policyDefinitionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        policyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        policyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getBuiltInOperationSpec$1 = {
    path: "/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, policyDefinitionName],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateAtManagementGroupOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: PolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        managementGroupId,
        policyDefinitionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteAtManagementGroupOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        managementGroupId,
        policyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getAtManagementGroupOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policyDefinitions/{policyDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        managementGroupId,
        policyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2
};
const listBuiltInOperationSpec$1 = {
    path: "/providers/Microsoft.Authorization/policyDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByManagementGroupOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policyDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host, managementGroupId],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listBuiltInNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByManagementGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PolicySetDefinitions operations. */
class PolicySetDefinitionsImpl {
    /**
     * Initialize a new instance of the class PolicySetDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation retrieves a list of all the policy set definitions in a given subscription that match
     * the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}'
     * or 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all policy set
     * definitions associated with the subscription, including those that apply directly or from management
     * groups that contain the given subscription. If $filter=atExactScope() is provided, the returned list
     * only includes all policy set definitions that at the given subscription. If $filter='policyType -eq
     * {value}' is provided, the returned list only includes all policy set definitions whose type match
     * the {value}. Possible policyType values are NotSpecified, BuiltIn and Custom. If $filter='category
     * -eq {value}' is provided, the returned list only includes all policy set definitions whose category
     * match the {value}.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation retrieves a list of all the built-in policy set definitions that match the optional
     * given $filter. If $filter='category -eq {value}' is provided, the returned list only includes all
     * built-in policy set definitions whose category match the {value}.
     * @param options The options parameters.
     */
    listBuiltIn(options) {
        const iter = this.listBuiltInPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBuiltInPagingPage(options, settings);
            }
        };
    }
    listBuiltInPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBuiltInPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBuiltIn(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBuiltInNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBuiltInPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBuiltInPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBuiltInPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * This operation retrieves a list of all the policy set definitions in a given management group that
     * match the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq
     * {value}' or 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all
     * policy set definitions associated with the management group, including those that apply directly or
     * from management groups that contain the given management group. If $filter=atExactScope() is
     * provided, the returned list only includes all policy set definitions that at the given management
     * group. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy
     * set definitions whose type match the {value}. Possible policyType values are NotSpecified, BuiltIn
     * and Custom. If $filter='category -eq {value}' is provided, the returned list only includes all
     * policy set definitions whose category match the {value}.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    listByManagementGroup(managementGroupId, options) {
        const iter = this.listByManagementGroupPagingAll(managementGroupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByManagementGroupPagingPage(managementGroupId, options, settings);
            }
        };
    }
    listByManagementGroupPagingPage(managementGroupId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagementGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByManagementGroup(managementGroupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagementGroupNext(managementGroupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByManagementGroupPagingAll(managementGroupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagementGroupPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByManagementGroupPagingPage(managementGroupId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * This operation creates or updates a policy set definition in the given subscription with the given
     * name.
     * @param policySetDefinitionName The name of the policy set definition to create.
     * @param parameters The policy set definition properties.
     * @param options The options parameters.
     */
    createOrUpdate(policySetDefinitionName, parameters, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, parameters, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * This operation deletes the policy set definition in the given subscription with the given name.
     * @param policySetDefinitionName The name of the policy set definition to delete.
     * @param options The options parameters.
     */
    delete(policySetDefinitionName, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, options }, deleteOperationSpec$1);
    }
    /**
     * This operation retrieves the policy set definition in the given subscription with the given name.
     * @param policySetDefinitionName The name of the policy set definition to get.
     * @param options The options parameters.
     */
    get(policySetDefinitionName, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, options }, getOperationSpec$1);
    }
    /**
     * This operation retrieves the built-in policy set definition with the given name.
     * @param policySetDefinitionName The name of the policy set definition to get.
     * @param options The options parameters.
     */
    getBuiltIn(policySetDefinitionName, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, options }, getBuiltInOperationSpec);
    }
    /**
     * This operation retrieves a list of all the policy set definitions in a given subscription that match
     * the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq {value}'
     * or 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all policy set
     * definitions associated with the subscription, including those that apply directly or from management
     * groups that contain the given subscription. If $filter=atExactScope() is provided, the returned list
     * only includes all policy set definitions that at the given subscription. If $filter='policyType -eq
     * {value}' is provided, the returned list only includes all policy set definitions whose type match
     * the {value}. Possible policyType values are NotSpecified, BuiltIn and Custom. If $filter='category
     * -eq {value}' is provided, the returned list only includes all policy set definitions whose category
     * match the {value}.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * This operation retrieves a list of all the built-in policy set definitions that match the optional
     * given $filter. If $filter='category -eq {value}' is provided, the returned list only includes all
     * built-in policy set definitions whose category match the {value}.
     * @param options The options parameters.
     */
    _listBuiltIn(options) {
        return this.client.sendOperationRequest({ options }, listBuiltInOperationSpec);
    }
    /**
     * This operation creates or updates a policy set definition in the given management group with the
     * given name.
     * @param policySetDefinitionName The name of the policy set definition to create.
     * @param managementGroupId The ID of the management group.
     * @param parameters The policy set definition properties.
     * @param options The options parameters.
     */
    createOrUpdateAtManagementGroup(policySetDefinitionName, managementGroupId, parameters, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, managementGroupId, parameters, options }, createOrUpdateAtManagementGroupOperationSpec);
    }
    /**
     * This operation deletes the policy set definition in the given management group with the given name.
     * @param policySetDefinitionName The name of the policy set definition to delete.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    deleteAtManagementGroup(policySetDefinitionName, managementGroupId, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, managementGroupId, options }, deleteAtManagementGroupOperationSpec);
    }
    /**
     * This operation retrieves the policy set definition in the given management group with the given
     * name.
     * @param policySetDefinitionName The name of the policy set definition to get.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    getAtManagementGroup(policySetDefinitionName, managementGroupId, options) {
        return this.client.sendOperationRequest({ policySetDefinitionName, managementGroupId, options }, getAtManagementGroupOperationSpec);
    }
    /**
     * This operation retrieves a list of all the policy set definitions in a given management group that
     * match the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType -eq
     * {value}' or 'category eq '{value}''. If $filter is not provided, the unfiltered list includes all
     * policy set definitions associated with the management group, including those that apply directly or
     * from management groups that contain the given management group. If $filter=atExactScope() is
     * provided, the returned list only includes all policy set definitions that at the given management
     * group. If $filter='policyType -eq {value}' is provided, the returned list only includes all policy
     * set definitions whose type match the {value}. Possible policyType values are NotSpecified, BuiltIn
     * and Custom. If $filter='category -eq {value}' is provided, the returned list only includes all
     * policy set definitions whose category match the {value}.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    _listByManagementGroup(managementGroupId, options) {
        return this.client.sendOperationRequest({ managementGroupId, options }, listByManagementGroupOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
    /**
     * ListBuiltInNext
     * @param nextLink The nextLink from the previous successful call to the ListBuiltIn method.
     * @param options The options parameters.
     */
    _listBuiltInNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBuiltInNextOperationSpec);
    }
    /**
     * ListByManagementGroupNext
     * @param managementGroupId The ID of the management group.
     * @param nextLink The nextLink from the previous successful call to the ListByManagementGroup method.
     * @param options The options parameters.
     */
    _listByManagementGroupNext(managementGroupId, nextLink, options) {
        return this.client.sendOperationRequest({ managementGroupId, nextLink, options }, listByManagementGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicySetDefinition
        },
        201: {
            bodyMapper: PolicySetDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        policySetDefinitionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        policySetDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        policySetDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getBuiltInOperationSpec = {
    path: "/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, policySetDefinitionName],
    headerParameters: [accept],
    serializer: serializer$1
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policySetDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBuiltInOperationSpec = {
    path: "/providers/Microsoft.Authorization/policySetDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateAtManagementGroupOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicySetDefinition
        },
        201: {
            bodyMapper: PolicySetDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        managementGroupId,
        policySetDefinitionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteAtManagementGroupOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        managementGroupId,
        policySetDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getAtManagementGroupOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policySetDefinitions/{policySetDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        managementGroupId,
        policySetDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByManagementGroupOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policySetDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion1, top],
    urlParameters: [$host, managementGroupId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBuiltInNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByManagementGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicySetDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PolicyExemptions operations. */
class PolicyExemptionsImpl {
    /**
     * Initialize a new instance of the class PolicyExemptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation retrieves the list of all policy exemptions associated with the given subscription
     * that match the optional given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()',
     * 'excludeExpired()' or 'policyAssignmentId eq '{value}''. If $filter is not provided, the unfiltered
     * list includes all policy exemptions associated with the subscription, including those that apply
     * directly or from management groups that contain the given subscription, as well as any applied to
     * objects contained within the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation retrieves the list of all policy exemptions associated with the given resource group
     * in the given subscription that match the optional given $filter. Valid values for $filter are:
     * 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''. If $filter
     * is not provided, the unfiltered list includes all policy exemptions associated with the resource
     * group, including those that apply directly or apply from containing scopes, as well as any applied
     * to resources contained within the resource group.
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param options The options parameters.
     */
    listForResourceGroup(resourceGroupName, options) {
        const iter = this.listForResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listForResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listForResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * This operation retrieves the list of all policy exemptions associated with the specified resource in
     * the given resource group and subscription that match the optional given $filter. Valid values for
     * $filter are: 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''.
     * If $filter is not provided, the unfiltered list includes all policy exemptions associated with the
     * resource, including those that apply directly or from all containing scopes, as well as any applied
     * to resources contained within the resource. Three parameters plus the resource name are used to
     * identify a specific resource. If the resource is not part of a parent resource (the more common
     * case), the parent resource path should not be provided (or provided as ''). For example a web app
     * could be specified as ({resourceProviderNamespace} == 'Microsoft.Web', {parentResourcePath} == '',
     * {resourceType} == 'sites', {resourceName} == 'MyWebApp'). If the resource is part of a parent
     * resource, then all parameters should be provided. For example a virtual machine DNS name could be
     * specified as ({resourceProviderNamespace} == 'Microsoft.Compute', {parentResourcePath} ==
     * 'virtualMachines/MyVirtualMachine', {resourceType} == 'domainNames', {resourceName} ==
     * 'MyComputerName'). A convenient alternative to providing the namespace and type name separately is
     * to provide both in the {resourceType} parameter, format: ({resourceProviderNamespace} == '',
     * {parentResourcePath} == '', {resourceType} == 'Microsoft.Web/sites', {resourceName} == 'MyWebApp').
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param resourceProviderNamespace The namespace of the resource provider. For example, the namespace
     *                                  of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)
     * @param parentResourcePath The parent resource path. Use empty string if there is none.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The name of the resource.
     * @param options The options parameters.
     */
    listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        const iter = this.listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings);
            }
        };
    }
    listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForResourcePagingAll(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForResourcePagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listForResourcePagingPage(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * This operation retrieves the list of all policy exemptions applicable to the management group that
     * match the given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()',
     * 'excludeExpired()' or 'policyAssignmentId eq '{value}''. If $filter=atScope() is provided, the
     * returned list includes all policy exemptions that are assigned to the management group or the
     * management group's ancestors.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    listForManagementGroup(managementGroupId, options) {
        const iter = this.listForManagementGroupPagingAll(managementGroupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listForManagementGroupPagingPage(managementGroupId, options, settings);
            }
        };
    }
    listForManagementGroupPagingPage(managementGroupId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listForManagementGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listForManagementGroup(managementGroupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listForManagementGroupNext(managementGroupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listForManagementGroupPagingAll(managementGroupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listForManagementGroupPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listForManagementGroupPagingPage(managementGroupId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * This operation deletes a policy exemption, given its name and the scope it was created in. The scope
     * of a policy exemption is the part of its ID preceding
     * '/providers/Microsoft.Authorization/policyExemptions/{policyExemptionName}'.
     * @param scope The scope of the policy exemption. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyExemptionName The name of the policy exemption to delete.
     * @param options The options parameters.
     */
    delete(scope, policyExemptionName, options) {
        return this.client.sendOperationRequest({ scope, policyExemptionName, options }, deleteOperationSpec);
    }
    /**
     *  This operation creates or updates a policy exemption with the given scope and name. Policy
     * exemptions apply to all resources contained within their scope. For example, when you create a
     * policy exemption at resource group scope for a policy assignment at the same or above level, the
     * exemption exempts to all applicable resources in the resource group.
     * @param scope The scope of the policy exemption. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyExemptionName The name of the policy exemption to delete.
     * @param parameters Parameters for the policy exemption.
     * @param options The options parameters.
     */
    createOrUpdate(scope, policyExemptionName, parameters, options) {
        return this.client.sendOperationRequest({ scope, policyExemptionName, parameters, options }, createOrUpdateOperationSpec);
    }
    /**
     * This operation retrieves a single policy exemption, given its name and the scope it was created at.
     * @param scope The scope of the policy exemption. Valid scopes are: management group (format:
     *              '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format:
     *              '/subscriptions/{subscriptionId}'), resource group (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'
     * @param policyExemptionName The name of the policy exemption to delete.
     * @param options The options parameters.
     */
    get(scope, policyExemptionName, options) {
        return this.client.sendOperationRequest({ scope, policyExemptionName, options }, getOperationSpec);
    }
    /**
     * This operation retrieves the list of all policy exemptions associated with the given subscription
     * that match the optional given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()',
     * 'excludeExpired()' or 'policyAssignmentId eq '{value}''. If $filter is not provided, the unfiltered
     * list includes all policy exemptions associated with the subscription, including those that apply
     * directly or from management groups that contain the given subscription, as well as any applied to
     * objects contained within the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * This operation retrieves the list of all policy exemptions associated with the given resource group
     * in the given subscription that match the optional given $filter. Valid values for $filter are:
     * 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''. If $filter
     * is not provided, the unfiltered list includes all policy exemptions associated with the resource
     * group, including those that apply directly or apply from containing scopes, as well as any applied
     * to resources contained within the resource group.
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param options The options parameters.
     */
    _listForResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listForResourceGroupOperationSpec);
    }
    /**
     * This operation retrieves the list of all policy exemptions associated with the specified resource in
     * the given resource group and subscription that match the optional given $filter. Valid values for
     * $filter are: 'atScope()', 'atExactScope()', 'excludeExpired()' or 'policyAssignmentId eq '{value}''.
     * If $filter is not provided, the unfiltered list includes all policy exemptions associated with the
     * resource, including those that apply directly or from all containing scopes, as well as any applied
     * to resources contained within the resource. Three parameters plus the resource name are used to
     * identify a specific resource. If the resource is not part of a parent resource (the more common
     * case), the parent resource path should not be provided (or provided as ''). For example a web app
     * could be specified as ({resourceProviderNamespace} == 'Microsoft.Web', {parentResourcePath} == '',
     * {resourceType} == 'sites', {resourceName} == 'MyWebApp'). If the resource is part of a parent
     * resource, then all parameters should be provided. For example a virtual machine DNS name could be
     * specified as ({resourceProviderNamespace} == 'Microsoft.Compute', {parentResourcePath} ==
     * 'virtualMachines/MyVirtualMachine', {resourceType} == 'domainNames', {resourceName} ==
     * 'MyComputerName'). A convenient alternative to providing the namespace and type name separately is
     * to provide both in the {resourceType} parameter, format: ({resourceProviderNamespace} == '',
     * {parentResourcePath} == '', {resourceType} == 'Microsoft.Web/sites', {resourceName} == 'MyWebApp').
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param resourceProviderNamespace The namespace of the resource provider. For example, the namespace
     *                                  of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)
     * @param parentResourcePath The parent resource path. Use empty string if there is none.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The name of the resource.
     * @param options The options parameters.
     */
    _listForResource(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            options
        }, listForResourceOperationSpec);
    }
    /**
     * This operation retrieves the list of all policy exemptions applicable to the management group that
     * match the given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()',
     * 'excludeExpired()' or 'policyAssignmentId eq '{value}''. If $filter=atScope() is provided, the
     * returned list includes all policy exemptions that are assigned to the management group or the
     * management group's ancestors.
     * @param managementGroupId The ID of the management group.
     * @param options The options parameters.
     */
    _listForManagementGroup(managementGroupId, options) {
        return this.client.sendOperationRequest({ managementGroupId, options }, listForManagementGroupOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListForResourceGroupNext
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param nextLink The nextLink from the previous successful call to the ListForResourceGroup method.
     * @param options The options parameters.
     */
    _listForResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listForResourceGroupNextOperationSpec);
    }
    /**
     * ListForResourceNext
     * @param resourceGroupName The name of the resource group containing the resource.
     * @param resourceProviderNamespace The namespace of the resource provider. For example, the namespace
     *                                  of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)
     * @param parentResourcePath The parent resource path. Use empty string if there is none.
     * @param resourceType The resource type name. For example the type name of a web app is 'sites' (from
     *                     Microsoft.Web/sites).
     * @param resourceName The name of the resource.
     * @param nextLink The nextLink from the previous successful call to the ListForResource method.
     * @param options The options parameters.
     */
    _listForResourceNext(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listForResourceNextOperationSpec);
    }
    /**
     * ListForManagementGroupNext
     * @param managementGroupId The ID of the management group.
     * @param nextLink The nextLink from the previous successful call to the ListForManagementGroup method.
     * @param options The options parameters.
     */
    _listForManagementGroupNext(managementGroupId, nextLink, options) {
        return this.client.sendOperationRequest({ managementGroupId, nextLink, options }, listForManagementGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/policyExemptions/{policyExemptionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        policyExemptionName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/policyExemptions/{policyExemptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PolicyExemption
        },
        201: {
            bodyMapper: PolicyExemption
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        policyExemptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/{scope}/providers/Microsoft.Authorization/policyExemptions/{policyExemptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemption
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        scope,
        policyExemptionName
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyExemptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listForResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/policyExemptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const listForResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/policyExemptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer
};
const listForManagementGroupOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Authorization/policyExemptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion2],
    urlParameters: [$host, managementGroupId],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const listForResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const listForResourceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer
};
const listForManagementGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyExemptionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class PolicyClient extends coreClient__namespace.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (!subscriptionIdOrOptions !== undefined) {
            if (typeof subscriptionIdOrOptions === "string") {
                subscriptionId = subscriptionIdOrOptions;
            }
            else if (typeof subscriptionIdOrOptions === "object") {
                options = subscriptionIdOrOptions;
            }
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-policy/5.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.dataPolicyManifests = new DataPolicyManifestsImpl(this);
        this.policyAssignments = new PolicyAssignmentsImpl(this);
        this.policyDefinitions = new PolicyDefinitionsImpl(this);
        this.policySetDefinitions = new PolicySetDefinitionsImpl(this);
        this.policyExemptions = new PolicyExemptionsImpl(this);
    }
}

exports.PolicyClient = PolicyClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
